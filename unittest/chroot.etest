#!/usr/bin/env bash
#
# Copyright 2011-2018, SolidFire, Inc. All rights reserved.
#
# This program is free software: you can redistribute it and/or modify it under the terms of the Apache License
# as published by the Apache Software Foundation, either version 2 of the License, or (at your option) any later
# version.

[[ ${__BU_OS} == Linux ]] || return 0

source ${BASHUTILS_HOME}/unittest/daemon_expect.sh

setup()
{
    # NOTE: We create the CHROOT a directory above our normal output directory so that it survives a single test's
    # normal setup/teardown infrastructure. This allows us to re-use the CHROOT within this file for each subsequent
    # test to avoid the massive overhead of re-creating it every time.
    CHROOT=$(readlink -m ${TEST_DIR_OUTPUT}/../chroot)

    if [[ ! -e "${CHROOT}" ]]; then
        einfo "Making chroot in ${CHROOT}"
        efreshdir ${CHROOT}
        etestmsg "Cleaned ${CHROOT}"
        mkchroot ${CHROOT} precise oxygen bdr-jenkins.den.solidfire.net amd64
        etestmsg "Finished creating ${CHROOT}"
    else
        etestmsg "Chroot was previously created via setup routine -- verifying it looks minimally sane."
        assert test -x ${CHROOT}/bin/bash
    fi
}

teardown()
{
    chroot_kill

    # A known bug in bash (fixed in 4.3) causes exit traps not to be executed sometimes.  This seems
    # to manifest itself when using our daemon functions in chroots, and the exit trap not executing
    # leaks a mount.
    #
    # This only seems to affect bash 4.2.  DT-250 (https://solidfire.atlassian.net/browse/DT-250)
    # will hopefully improve the daemon code so that this workaround is no longer necessary.
    #
    if [[ ${BASH_VERSION} == 4.2* ]] ; then
        eunmount --recursive --all ${CHROOT}
    fi

    # NOTE: We do not delete the CHROOT itself here because we want to be able to re-use it for each test to avoid
    # the massive overhad of recreating it every time. It will get automatically claned up when etest cleans up for
    # us.
    eunmount --recursive ${CHROOT}
}

check_mounts()
{
    $(opt_parse count)

    # Verify chroot paths not mounted
    for path in ${CHROOT_MOUNTS[@]}; do
        
        if [[ ${count} -eq 0 ]]; then
            assert_false emounted ${CHROOT}${path}
        else
            assert_true emounted ${CHROOT}${path}
        fi

        assert_eq ${count} $(emount_count ${CHROOT}${path})
    done
}

ETEST_chroot_readlink()
{
    local real=$(chroot_readlink /var/run)
    assert_eq "${CHROOT}/run" "${real}"
}

ETEST_chroot_create_mount()
{
    check_mounts 0

    # Mount a few times and verify counts go up
    local nmounts=10
    for (( i=0; i<${nmounts}; ++i )); do
        chroot_mount
        check_mounts $((i+1))
    done

    # Unmount and verify counts go down
    for (( i=${nmounts}; i>0; --i )); do
        chroot_unmount
        check_mounts $((i-1))
    done

    check_mounts 0
}

# Ensure if we have multiple chroot_mounts going on that we can successfully
# unmount them properly using a single call to eunmount.
ETEST_chroot_create_mount_unmount_recursive()
{
    check_mounts 0

    # Mount a few times and verify counts go up
    local nmounts=10
    for (( i=0; i<${nmounts}; ++i )); do
        chroot_mount
        check_mounts $((i+1))
    done

    # One eunmount -a -r (all) should clean everything up resursively.
    eunmount -a -r ${CHROOT}
    check_mounts 0
}

# A problem that we've had repeatedly is after using chroot_mount, our root
# system gets honked up.  This seems to be related to shared/private mounts.
# Here we create a file on the root system in /dev/shm, which will go away if
# that problem occurs.  This seems to occur only on systems that mount /dev as
# shared initially (e.g. those running systemd)
ETEST_chroot_slash_dev_shared_mounts()
{
    TESTFILE=/dev/shm/${FUNCNAME}_$$

    touch ${TESTFILE}
    [[ -f ${TESTFILE} ]] || die "Unable to create ${TESTFILE}"
    trap_add "rm ${TESTFILE}"

    # Force /dev to be mounted "shared" so that the following code can test
    # whether it actually works that way.  This is the default on systemd
    # boxes, but not others
    mount --make-shared /dev

    mkdir dev

    ebindmount /dev dev
    ebindmount /dev dev
    trap_add "eunmount dev dev"

    # So now, while we've done a pair of bind mounts, the file should be missing
    [[ -f ${TESTFILE} ]] || die "File is missing"
}

ETEST_chroot_kill()
{
    chroot_mount
    trap_add "chroot_exit"

    etestmsg "Starting some chroot processes"
    chroot_cmd "cat&            echo \$! >> /tmp/pids"
    chroot_cmd "sleep infinity& echo \$! >> /tmp/pids"
    local pids=()
    array_init pids "$(cat ${CHROOT}/tmp/pids)"
    etestmsg "$(lval pids)"

    etestmsg "Killing cat"
    chroot_kill "cat"
    eretry -t=2s -T=30s process_not_running ${pids[0]}
    process_running ${pids[1]}

    etestmsg "Killing everything..."
    chroot_kill
    eretry -t=2s -T=30s process_not_running ${pids[0]}
    eretry -t=2s -T=30s process_not_running ${pids[1]}
}

ETEST_chroot_install()
{
    chroot_mount
    trap_add "chroot_exit"

    chroot_install "bashutils-sfdev-precise-1.0.1>=5"
    chroot_uninstall "bashutils-sfdev-precise-1.0.1"

    # Empty
    chroot_install
    chroot_uninstall
}

# This test verifies a portion of ebindmount that can only readily be demonstrated inside a chroot.
# Once inside, you're no longer able to see mountpoints that exist on the filesystem outside the
# chroot.  But ebindmount attempts to call mount --make-rprivate on the source of things it bind
# mounts.  If it cannot see them, it fails.
#
# This test thus does a bind mount from something that would be on a filesystem whose mount point
# the chroot cannot see.
ETEST_chroot_ebindmount()
{
    chroot_mount
    trap_add "chroot_exit"

    local dirname=${FUNCNAME}-$BASHPID-$$

    chroot_cmd 'mkdir /'"${dirname}"
    chroot_cmd 'mkdir /'"${dirname}-bound"

    # Bind mount bashutils into the chroot so we can call ebindmount from that
    ebindmount "${BASHUTILS_HOME}" "${CHROOT}/${dirname}"

    # Bind a local directory to another at the top of the hierarchy so we can be sure the filesystem
    # source of the first is a filesystem whose root we cannot see in this chroot
    chroot_cmd "BASHUTILS_HOME=/${dirname} BASHUTILS=${dirname}/share /${dirname}/bin/bashutils ebindmount /${dirname} /${dirname}-bound"

    assert_exists "${CHROOT}/${dirname}-bound/share/bashutils.sh"

    # Clean up
    eunmount -r "${CHROOT}/${dirname}"
}

#-----------------------------------------------------------------------------
# CHROOT DAEMON TESTS
#-----------------------------------------------------------------------------

ETEST_chroot_daemon_start_stop()
{
    chroot_mount
    trap_add "chroot_exit"

    local pidfile="${FUNCNAME}.pid"
    local sleep_daemon
   
    daemon_init sleep_daemon     \
        "${DAEMON_EXPECT[@]}"    \
        chroot="${CHROOT}"       \
        name="Infinity"          \
        cmdline="sleep infinity" \
        logfile="logfile.log"    \
        pidfile="${pidfile}"

    etestmsg "Starting chroot daemon"
    daemon_start sleep_daemon
    daemon_expect pre_start
    daemon_expect post_mount
    etestmsg "Started successfully"
    
    # Now stop it and verify proper shutdown
    etestmsg "Stopping chroot daemon"
    local pid=$(cat ${pidfile})
    daemon_stop sleep_daemon &
    daemon_expect pre_stop
    daemon_expect post_stop
    wait
    etestmsg "Stopped successfully"
}

# Test that verifies additional bindmounts can be specified to chroot daemons
ETEST_chroot_daemon_bindmount()
{
    chroot_mount
    trap_add "chroot_exit"

    etestmsg "Creating temporary directories"
    local tmpdir1=$(mktemp --tmpdir --directory ${FUNCNAME}1-XXXXXX)
    local tmpdir2=$(mktemp --tmpdir --directory ${FUNCNAME}2-XXXXXX)
    trap_add "eunmount -r -d ${tmpdir1} ${tmpdir2}"
    touch ${tmpdir1}/{1,2,3,4,5} ${tmpdir2}/{1,2,3,4,5}

    etestmsg "Initializating daemon"
    local pidfile="${FUNCNAME}.pid"
    local sleep_daemon
    daemon_init sleep_daemon                 \
        "${DAEMON_EXPECT[@]}"                \
        bindmounts="${tmpdir1} ${tmpdir2}"   \
        chroot="${CHROOT}"                   \
        name="daemon with bindmount"         \
        cmdline="sleep infinity"             \
        logfile="logfile.log"                \
        pidfile="${pidfile}"

    etestmsg "Starting chroot daemon"
    daemon_start sleep_daemon
    daemon_expect pre_start
    daemon_expect post_mount

    # Verify mounts are mounted
    etestmsg "Verifying mounts were mounted"
    assert_true emounted ${CHROOT}/${tmpdir1}
    assert_true emounted ${CHROOT}/${tmpdir2}

    # Stop the daemon
    etestmsg "Stopping daemon"
    daemon_stop sleep_daemon &
    daemon_expect pre_stop
    daemon_expect post_stop
    wait

    etestmsg "Begin daemon logfile"
    echo "$(ecolor salmon)"
    cat logfile.log
    etestmsg "End daemon logfile"

    # Verify mounts are NOT mounted
    etestmsg "Verifying mounts were unmounted"
    einfo "${CHROOT}${tmpdir1}"
    assert_false emounted ${CHROOT}/${tmpdir1}
    einfo "${CHROOT}${tmpdir1}"
    assert_false emounted ${CHROOT}/${tmpdir2}
}

ETEST_chroot_daemon_bindmount_file()
{
    chroot_mount
    trap_add "chroot_exit"

    etestmsg "Creating temporary directories"
    local tmpdir1=$(mktemp --tmpdir --directory ${FUNCNAME}1-XXXXXX)
    local tmpdir2=$(mktemp --tmpdir --directory ${FUNCNAME}2-XXXXXX)
    trap_add "eunmount -r -d ${tmpdir1} ${tmpdir2}"
    touch ${tmpdir1}/{1,2,3,4,5} ${tmpdir2}/{1,2,3,4,5}
    local bindmounts=( $(find ${tmpdir1} ${tmpdir2} -type f) )
    local logfile=logfile.log
    touch ${tmpdir1}/XXX

    etestmsg "Initializating daemon $(lval bindmounts)"
    local pidfile="${FUNCNAME}.pid"
    local sleep_daemon
    daemon_init sleep_daemon                 \
        "${DAEMON_EXPECT[@]}"                \
        bindmounts="${bindmounts[*]} ${tmpdir1}/XXX:${tmpdir1}/YYY" \
        chroot="${CHROOT}"                   \
        name="Infinity"                      \
        cmdline="sleep infinity"             \
        logfile="${logfile} "                \
        pidfile="${pidfile}"

    etestmsg "Starting chroot daemon"
    daemon_start sleep_daemon
    daemon_expect pre_start
    daemon_expect post_mount

    # Verify mounts are mounted
    etestmsg "Verifying mounts were mounted"
    for mnt in "${bindmounts[@]} ${tmpdir1}/YYY"; do
        assert_true emounted ${CHROOT}/${mnt}
    done

    # Stop the daemon
    etestmsg "Stopping daemon"
    daemon_stop sleep_daemon &
    daemon_expect pre_stop
    daemon_expect post_stop
    wait

    # Verify mounts are NOT mounted
    etestmsg "Verifying mounts were unmounted"
    for mnt in "${bindmounts[@]} ${tmpdir1}/YYY"; do
        assert_false emounted ${CHROOT}/${mnt}
    done
}
