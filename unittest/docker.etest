#!/usr/bin/env bash
#
# Copyright 2011-2018, Marshall McMullen <marshall.mcmullen@gmail.com>
# Copyright 2011-2018, SolidFire, Inc. All rights reserved.
#
# This program is free software: you can redistribute it and/or modify it under the terms of the Apache License
# as published by the Apache Software Foundation, either version 2 of the License, or (at your option) any later
# version.

# Mock docker function to intercept "docker push" commands for better testability.
docker_tags_pushed=()
docker()
{
    if [[ "${1}" == "push" ]]; then
        etestmsg "Simulating docker push tags=${@}"
        shift
        docker_tags_pushed+=( "${@}" )
        return 0
    elif [[ "${1}" == "login" ]]; then
        etestmsg "Simulated docker login with args=${@}"
        return 0
    fi

    command docker "${@}"
}

setup()
{
    docker_tags_pushed=()
}

ETEST_docker_build()
{
    etestmsg "Creating Dockerfile"
	cat <<-END >Dockerfile
	FROM alpine:edge
	ENV CREATOR etest-$$
	ENTRYPOINT ["/bin/sh"]
	END
    cat Dockerfile

    etestmsg "Building docker image"
    docker_build --cache-repo "elibs/ebash"

    etestmsg "Validating docker_build artifacts"
    assert_exists \
        ".work"                            \
        ".work/docker"                     \
        ".work/docker/ebash.dockerfile"    \
        ".work/docker/ebash.history"       \
        ".work/docker/ebash.inspect"       \
        ".work/docker/ebash.options"       \
        ".work/docker/ebash.sha256"        \
        ".work/docker/ebash.sha256_short"  \
        ".work/docker/ebash.sha256_detail"

    etestmsg "Validating Docker Image was built"
    image="elibs/ebash:$(cat .work/docker/ebash.sha256_short)"
    etestmsg "$(lval image)"
    trap_add "docker rmi ${image}"

    assert_docker_image_exists "${image}"
}

# Verify if we use --pretend on a non-existant image that it returns 1 and doesn't do anything.
ETEST_docker_build_and_pretend()
{
    etestmsg "Creating Dockerfile"
	cat <<-END >Dockerfile
	FROM alpine:edge
	ENV CREATOR etest-$$
	ENTRYPOINT ["/bin/sh"]
	END
    cat Dockerfile

    etestmsg "Building docker image (PRETEND)"
    $(tryrc docker_build           \
        --cache-repo "elibs/ebash" \
        --pretend                  \
    )
    assert_eq 1 "${rc}"

    etestmsg "Validating docker_build artifacts"
    assert_exists \
        ".work"                            \
        ".work/docker"                     \
        ".work/docker/ebash.dockerfile"    \
        ".work/docker/ebash.sha256"        \
        ".work/docker/ebash.sha256_short"  \
        ".work/docker/ebash.sha256_detail"

    etestmsg "Validating docker_build artifacts that should NOT have been created"
    assert_not_exists \
        ".work/docker/ebash.history" \
        ".work/docker/ebash.inspect" \

    etestmsg "Validating Docker Image was NOT built"
    image="elibs/ebash:$(cat .work/docker/ebash.sha256_short)"
    etestmsg "$(lval image)"
    assert_docker_image_not_exists "${image}"
}

# Verify that provided build args are interpolated
ETEST_docker_build_args()
{
    etestmsg "Creating Dockerfile"
	cat <<-'END' >Dockerfile
	FROM alpine:edge
	ARG ARTIST
	ARG SONG
	RUN echo "${ARTIST}/${SONG}"
	ENTRYPOINT ["/bin/sh"]
	END
    cat Dockerfile

    etestmsg "Building docker image (pretend)"
    $(tryrc docker_build           \
        --pretend                  \
        --cache-repo "elibs/ebash" \
        --build-arg "ARTIST=James" \
        --build-arg "SONG=Laid"    \
    )
    assert_eq 1 "${rc}"

    etestmsg "Validating docker_build artifacts"
    assert_exists \
        ".work"                            \
        ".work/docker"                     \
        ".work/docker/ebash.dockerfile"    \
        ".work/docker/ebash.sha256"        \
        ".work/docker/ebash.sha256_short"  \
        ".work/docker/ebash.sha256_detail"

    etestmsg "Validating provided BUILD_ARGS are interpolated"
    assert_false diff "Dockerfile"            ".work/docker/ebash.dockerfile"
    assert_false grep "ARG ARTIST"            ".work/docker/ebash.dockerfile"
    assert_false grep "ARG SONG"              ".work/docker/ebash.dockerfile"
    assert_true  grep 'RUN echo "James/Laid"' ".work/docker/ebash.dockerfile"
}

# Verify that missing build args are NOT interpolated
ETEST_docker_build_args_missing()
{
    etestmsg "Creating Dockerfile"
	cat <<-END >Dockerfile
	FROM alpine:edge
	ARG UPR
	ENTRYPOINT ["/bin/sh"]
	END
    cat Dockerfile

    etestmsg "Building docker image (pretend)"
    $(tryrc docker_build           \
        --pretend                  \
        --cache-repo "elibs/ebash" \
    )
    assert_eq 1 "${rc}"

    etestmsg "Validating docker_build artifacts"
    assert_exists \
        ".work"                            \
        ".work/docker"                     \
        ".work/docker/ebash.dockerfile"    \
        ".work/docker/ebash.sha256"        \
        ".work/docker/ebash.sha256_short"  \
        ".work/docker/ebash.sha256_detail"

    etestmsg "Validating missing BUILD_ARGS are not interpolated"
    diff "Dockerfile" ".work/docker/ebash.dockerfile"
}

# Custom dockerfile name
ETEST_docker_build_custom_dockerfile()
{
    local file="Dockerfile.foobar"
    etestmsg "Creating Dockerfile=${file}"
	cat <<-END >${file}
	FROM alpine:edge
	ENV CREATOR etest-$$
	ENTRYPOINT ["/bin/sh"]
	END
    cat "${file}"

    etestmsg "Building docker image"
    docker_build                   \
        --cache-repo "elibs/ebash" \
        --file "${file}"

    etestmsg "Validating docker_build artifacts"
    assert_exists \
        ".work"                            \
        ".work/docker"                     \
        ".work/docker/ebash.dockerfile"    \
        ".work/docker/ebash.history"       \
        ".work/docker/ebash.inspect"       \
        ".work/docker/ebash.options"       \
        ".work/docker/ebash.sha256"        \
        ".work/docker/ebash.sha256_short"  \
        ".work/docker/ebash.sha256_detail"

    etestmsg "Validating Docker Image was built"
    image="elibs/ebash:$(cat .work/docker/ebash.sha256_short)"
    etestmsg "$(lval image)"
    trap_add "docker rmi ${image}"

    assert_docker_image_exists "${image}"
}

# Custom dockerfile and custom artifact name
ETEST_docker_build_custom_dockerfile()
{
    local file="Dockerfile.foobar"
    etestmsg "Creating Dockerfile=${file}"
	cat <<-END >${file}
	FROM alpine:edge
	ENV CREATOR etest-$$
	ENTRYPOINT ["/bin/sh"]
	END
    cat "${file}"

    etestmsg "Building docker image"
    docker_build                   \
        --cache-repo "elibs/ebash" \
        --name "elibs_ebash"       \
        --file "${file}"

    etestmsg "Validating docker_build artifacts"
    assert_exists \
        ".work"                                  \
        ".work/docker"                           \
        ".work/docker/elibs_ebash.dockerfile"    \
        ".work/docker/elibs_ebash.history"       \
        ".work/docker/elibs_ebash.inspect"       \
        ".work/docker/elibs_ebash.options"       \
        ".work/docker/elibs_ebash.sha256"        \
        ".work/docker/elibs_ebash.sha256_short"  \
        ".work/docker/elibs_ebash.sha256_detail"

    etestmsg "Validating Docker Image was built"
    image="elibs/ebash:$(cat .work/docker/elibs_ebash.sha256_short)"
    etestmsg "$(lval image)"
    trap_add "docker rmi ${image}"

    assert_docker_image_exists "${image}"
}

ETEST_docker_custom_shafunc()
{
    etestmsg "Creating Dockerfile"
	cat <<-END >Dockerfile
	FROM alpine:edge
	ENV CREATOR etest-$$
	ENTRYPOINT ["/bin/sh"]
	END
    cat Dockerfile

    etestmsg "Building docker image"
    docker_build                   \
        --cache-repo "elibs/ebash" \
        --shafunc sha512

    etestmsg "Validating docker_build artifacts"
    assert_exists \
        ".work"                            \
        ".work/docker"                     \
        ".work/docker/ebash.dockerfile"    \
        ".work/docker/ebash.history"       \
        ".work/docker/ebash.inspect"       \
        ".work/docker/ebash.options"       \
        ".work/docker/ebash.sha512"        \
        ".work/docker/ebash.sha512_short"  \
        ".work/docker/ebash.sha512_detail"

    etestmsg "Validating Docker Image was built"
    image="elibs/ebash:$(cat .work/docker/ebash.sha512_short)"
    etestmsg "$(lval image)"
    trap_add "docker rmi ${image}"

    assert_docker_image_exists "${image}"
}

# Verify we can provide multiple additional tags and that all get created
ETEST_docker_build_tags()
{
    etestmsg "Creating Dockerfile"
	cat <<-END >Dockerfile
	FROM alpine:edge
	ENV CREATOR etest-$$
	ENTRYPOINT ["/bin/sh"]
	END
    cat Dockerfile

    local tags=(
        "elibs/ebash:etest-$$-tag1"
        "elibs/ebash:etest-$$-tag2"
        "elibs/ebash-cicd:$$"
        "foo"
        "bar"
        "zap"
    )

    etestmsg "Building docker image"
    eval "docker_build --cache-repo elibs/ebash $(array_join --before tags ' --tag ')"
    trap_add "docker rmi ${tags[*]}"

    etestmsg "Validating docker_build artifacts"
    assert_exists \
        ".work"                            \
        ".work/docker"                     \
        ".work/docker/ebash.dockerfile"    \
        ".work/docker/ebash.history"       \
        ".work/docker/ebash.inspect"       \
        ".work/docker/ebash.options"       \
        ".work/docker/ebash.sha256"        \
        ".work/docker/ebash.sha256_short"  \
        ".work/docker/ebash.sha256_detail"

    etestmsg "Validating Docker Image was built"
    image="elibs/ebash:$(cat .work/docker/ebash.sha256_short)"
    etestmsg "$(lval image)"
    trap_add "docker rmi ${image}"
    assert_docker_image_exists "${image}"

    etestmsg "Validating all tags were built"
    for tag in ${tags[@]}; do
        echo "${tag}"
        assert_docker_image_exists "${tag}"
    done
}

# Verify pushing tags works properly. Mock out docker() so that we don't have to actually have an upstream to push to.
ETEST_docker_build_tags_push()
{
    etestmsg "Creating Dockerfile"
	cat <<-END >Dockerfile
	FROM alpine:edge
	ENV CREATOR etest-$$
	ENTRYPOINT ["/bin/sh"]
	END
    cat Dockerfile

    local tags=(
        "elibs/ebash:etest-$$-tag1"
        "elibs/ebash:etest-$$-tag2"
        "elibs/ebash-cicd:$$"
        "foo"
        "bar"
        "zap"
    )

    etestmsg "Building docker image"
    eval "docker_build --cache-repo elibs/ebash --username neo --password matrix $(array_join --before tags ' --tag ') --push"

    etestmsg "Validating docker_build artifacts"
    assert_exists \
        ".work"                            \
        ".work/docker"                     \
        ".work/docker/ebash.dockerfile"    \
        ".work/docker/ebash.history"       \
        ".work/docker/ebash.inspect"       \
        ".work/docker/ebash.options"       \
        ".work/docker/ebash.sha256"        \
        ".work/docker/ebash.sha256_short"  \
        ".work/docker/ebash.sha256_detail"

    etestmsg "Validating Docker Image was built"
    image="elibs/ebash:$(cat .work/docker/ebash.sha256_short)"
    etestmsg "$(lval image)"
    trap_add "docker rmi ${image}"
    assert_docker_image_exists "${image}"

    etestmsg "Validating all tags were built"
    for tag in ${tags[@]}; do
        echo "${tag}"
        assert_docker_image_exists "${tag}"
    done

    etestmsg "Validating all tags were pushed"
    array_sort tags
    array_sort docker_tags_pushed
    etestmsg "$(lval tags docker_tags_pushed)"
    for tag in ${tags[@]}; do
        array_contains docker_tags_pushed "${tag}"
    done
}

# Verify if we create the same docker image multiple times in a row that it does NOT build it again but instead reuses
# the one we've locally built.
ETEST_docker_build_twice()
{
    etestmsg "Creating Dockerfile"
	cat <<-END >Dockerfile
	FROM alpine:edge
	ENV CREATOR etest-$$
	ENTRYPOINT ["/bin/sh"]
	END
    cat Dockerfile

    etestmsg "Building docker image"
    docker_build --cache-repo "elibs/ebash"

    etestmsg "Validating docker_build artifacts"
    assert_exists \
        ".work"                            \
        ".work/docker"                     \
        ".work/docker/ebash.dockerfile"    \
        ".work/docker/ebash.history"       \
        ".work/docker/ebash.inspect"       \
        ".work/docker/ebash.options"       \
        ".work/docker/ebash.sha256"        \
        ".work/docker/ebash.sha256_short"  \
        ".work/docker/ebash.sha256_detail"

    etestmsg "Validating Docker Image was built"
    image="elibs/ebash:$(cat .work/docker/ebash.sha256_short)"
    etestmsg "$(lval image)"
    assert_docker_image_exists "${image}"
    trap_add "docker rmi ${image}"

    for part in dockerfile history inspect sha256 sha256_short sha256_detail; do
        cp ".work/docker/ebash.${part}" ".work/docker/ebash.${part}.orig"
    done
    grep 'pretend="0"' ".work/docker/ebash.options"

    etestmsg "Building docker image (AGAIN)"
    docker_build         \
        --pretend        \
        --cache-repo "elibs/ebash"

    for part in dockerfile history inspect sha256 sha256_short sha256_detail; do
        etestmsg "Checking ${part}"
        # Depending on how fast this test runs, the output may say '1 second ago' or '2 seconds ago' which can cause
        # a false-positive failure. We don't actually care about that part of the history file so just remove it from
        # both files before we diff.
        if [[ "${part}" == "history" ]]; then

            diff ".work/docker/ebash.${part}.orig" ".work/docker/ebash.${part}" || true

            sed -i -e 's|[0-9]\+ seconds* ago\s*|1 second ago        |' \
                   -e 's|Less than a second ago\s*|1 second ago        |' \
                ".work/docker/ebash.${part}.orig" ".work/docker/ebash.${part}"
        fi

        diff ".work/docker/ebash.${part}.orig" ".work/docker/ebash.${part}"
    done
    grep 'pretend="1"' ".work/docker/ebash.options"

    created_expect=$(jq --raw-output '.[].Created' ".work/docker/ebash.inspect")
    created_actual=$(docker inspect --type image ${image} | jq --raw-output '.[].Created')
    assert_eq "${created_expect}" "${created_actual}"
}

# Verify if we make a small change to the Dockerfile that we won't reuse the previously built image.
ETEST_docker_build_twice_changed()
{
    etestmsg "Creating Dockerfile"
	cat <<-END >Dockerfile
	FROM alpine:edge
	ENV CREATOR etest-$$
	ENTRYPOINT ["/bin/sh"]
	END
    cat Dockerfile

    etestmsg "Building docker image"
    docker_build --cache-repo "elibs/ebash"

    etestmsg "Validating docker_build artifacts"
    assert_exists                          \
        ".work"                            \
        ".work/docker"                     \
        ".work/docker/ebash.dockerfile"    \
        ".work/docker/ebash.history"       \
        ".work/docker/ebash.inspect"       \
        ".work/docker/ebash.options"       \
        ".work/docker/ebash.sha256"        \
        ".work/docker/ebash.sha256_short"  \
        ".work/docker/ebash.sha256_detail"

    etestmsg "Validating Docker Image was built"
    image="elibs/ebash:$(cat .work/docker/ebash.sha256_short)"
    etestmsg "$(lval image)"
    assert_docker_image_exists "${image}"
    trap_add "docker rmi ${image}"

    for part in dockerfile sha256 sha256_short sha256_detail; do
        cp ".work/docker/ebash.${part}" ".work/docker/ebash.${part}.orig"
    done

    etestmsg "Modifying Dockerfile"
    cat <<-END >Dockerfile
	FROM alpine:edge
	ENV CREATOR etest-$$
	ENV TIMESTAMP $(etimestamp)
	ENTRYPOINT ["/bin/sh"]
	END
    cat Dockerfile

    etestmsg "Building docker image (AGAIN)"
    $(tryrc docker_build           \
        --pretend                  \
        --cache-repo "elibs/ebash" \
    )

    assert_eq 1 "${rc}"

    for part in dockerfile sha256 sha256_short sha256_detail; do
        assert_false diff ".work/docker/ebash.${part}.orig" ".work/docker/ebash.${part}"
    done
}

: <<'END'
ETEST_docker_build_systemctl_wrapper()
{
    etestmsg "Creating init"
	cat <<-'END' >init
	#!/bin/bash

	$(/ebash/bin/ebash --source)

	docker_create_systemctl_wrapper

	daemon_init sleeper1 \
	    autostart="yes"  \
	    cmdline="sleep infinity" \
        logfile="/var/log/sleeper1.log"

	daemon_init sleeper2 \
	    autostart="yes"  \
	    cmdline="sleep infinity" \
        logfile="/var/log/sleeper2.log"

	tail -f /dev/null
	END
    cat init
    chmod +x init

    etestmsg "Creating Dockerfile"
	cat <<-END >Dockerfile
	FROM ubuntu:20.04
	COPY "." "/ebash"
	COPY "${TEST_DIR_OUTPUT#${EBASH_HOME}/}/init" "/init"
	ENTRYPOINT ["/init"]
	END
    cat Dockerfile

    etestmsg "Building docker image"
    pushd "${TOPDIR}"
    docker_build --cache-repo "elibs/ebash" --file "${TEST_DIR_OUTPUT}/Dockerfile"
    image="elibs/ebash:$(cat .work/docker/ebash.sha256_short)"
    container_id=$(docker run --detach "${image}")
    trap_add "docker kill ${container_id}"
    eretry docker exec -t "${container_id}" bash -c "[[ -e /usr/local/bin/systemctl ]]"

    etestmsg "Validate systemctl wrapper"
    docker exec -t "${container_id}" systemctl status sleeper1
    docker exec -t "${container_id}" systemctl is-active sleeper1
    docker exec -t "${container_id}" systemctl status sleeper2
    docker exec -t "${container_id}" systemctl is-active sleeper2

    etestmsg "Stopping sleeper1 and sleeper2"
    docker exec -t "${container_id}" systemctl stop sleeper1
    docker exec -t "${container_id}" systemctl stop sleeper2
    assert_false docker exec -t "${container_id}" systemctl status sleeper1
    assert_false docker exec -t "${container_id}" systemctl status sleeper2
    docker exec -t "${container_id}" pgrep --full --inverse 'sleep infinity'

    etestmsg "Starting sleeper1"
    docker exec -t "${container_id}" systemctl start sleeper1
    eretry docker exec -t "${container_id}" systemctl status sleeper1

    etestmsg "Restarting sleeper1"
    docker exec -t "${container_id}" systemctl restart sleeper1
    eretry docker exec -t "${container_id}" systemctl status sleeper1

    etestmsg "Restarting sleeper2"
    docker exec -t "${container_id}" systemctl restart sleeper2
    eretry docker exec -t "${container_id}" systemctl status sleeper2
}
END

ETEST_docker_depends_sha()
{
    etestmsg "Creating Dockerfile"
	cat <<-END >Dockerfile
	FROM alpine:edge
	ENV CREATOR etest-$$
	ENTRYPOINT ["/bin/sh"]
	END
    cat Dockerfile

    etestmsg "Computing Dependency SHA"
    docker_depends_sha --cache-repo "elibs/ebash"

    etestmsg "Validating depends_sha artifacts"
    assert_exists \
        ".work"                            \
        ".work/docker"                     \
        ".work/docker/ebash.dockerfile"    \
        ".work/docker/ebash.options"       \
        ".work/docker/ebash.sha256"        \
        ".work/docker/ebash.sha256_short"  \
        ".work/docker/ebash.sha256_detail"

    etestmsg "Validating Docker Image was not built"
    image="elibs/ebash:$(cat .work/docker/ebash.sha256_short)"
    etestmsg "$(lval image)"
    assert_docker_image_not_exists "${image}"

    # Validate dependency SHA
    etestmsg "sha256"
    cat ".work/docker/ebash.sha256"

    etestmsg "details"
    cat ".work/docker/ebash.sha256_detail"
    expect=".work/docker/ebash.dockerfile@sha256:$(sha256sum Dockerfile | awk '{print $1}')"
    assert_eq "${expect}" "$(cat .work/docker/ebash.sha256_detail)"

    expect=$(sha256sum .work/docker/ebash.sha256_detail | awk '{print $1}')
    assert_eq "sha256:${expect}" "$(cat .work/docker/ebash.sha256)"
}
