#!/usr/bin/env bash
#
# Copyright 2011-2018, Marshall McMullen <marshall.mcmullen@gmail.com>
# Copyright 2011-2018, SolidFire, Inc. All rights reserved.
#
# This program is free software: you can redistribute it and/or modify it under the terms of the Apache License
# as published by the Apache Software Foundation, either version 2 of the License, or (at your option) any later
# version.

# Cannot get the docker tests to run properly on MacOS inside CI/CD so disable it for now.
[[ ${__EBASH_OS} == Linux ]] || return 0

# Mock docker function to intercept "docker push" commands for better testability.
docker_tags_pushed=()
docker()
{
    if [[ "${1}" == "push" ]]; then
        etestmsg "Simulating docker push tags=${@}"
        shift
        docker_tags_pushed+=( "${@}" )
        return 0
    elif [[ "${1}" == "login" ]]; then
        etestmsg "Simulated docker login with args=${@}"
        return 0
    fi

    command docker "${@}"
}

setup()
{
    docker_tags_pushed=()
}

ETEST_docker_build()
{
    etestmsg "Creating Dockerfile"
	cat <<-END >Dockerfile
	FROM alpine:edge
	ENV CREATOR etest-$$
	END
    cat Dockerfile

    etestmsg "Building docker image"
    docker_build --name "elibs/ebash"

    etestmsg "Validating docker_build artifacts"
    find ".work/docker/ebash" -ls
    assert_exists \
        ".work/docker/ebash/build.log"  \
        ".work/docker/ebash/dockerfile" \
        ".work/docker/ebash/history"    \
        ".work/docker/ebash/image"      \
        ".work/docker/ebash/inspect"    \
        ".work/docker/ebash/options"    \
        ".work/docker/ebash/sha"        \
        ".work/docker/ebash/sha.func"   \
        ".work/docker/ebash/sha.short"  \
        ".work/docker/ebash/sha.detail" \

    etestmsg "Validating Docker Image was built"
    image="$(cat .work/docker/ebash/image)"
    assert_eq "elibs/ebash:$(cat .work/docker/ebash/sha.short)" "${image}"
    etestmsg "$(lval image)"
    trap_add "docker rmi ${image}"

    assert_docker_image_exists "${image}"
}

# Verify if we use --pretend on a non-existant image that it returns 1 and doesn't do anything.
ETEST_docker_build_and_pretend()
{
    etestmsg "Creating Dockerfile"
	cat <<-END >Dockerfile
	FROM alpine:edge
	ENV CREATOR etest-$$
	END
    cat Dockerfile

    etestmsg "Building docker image (PRETEND)"
    $(tryrc docker_build     \
        --name "elibs/ebash" \
        --pretend            \
    )
    assert_eq 1 "${rc}"

    etestmsg "Validating docker_build artifacts"
    assert_exists \
        ".work/docker/ebash/dockerfile" \
        ".work/docker/ebash/image"      \
        ".work/docker/ebash/sha"        \
        ".work/docker/ebash/sha.func"   \
        ".work/docker/ebash/sha.short"  \
        ".work/docker/ebash/sha.detail" \

    etestmsg "Validating docker_build artifacts that should NOT have been created"
    assert_not_exists \
        ".work/docker/ebash/build.log"  \
        ".work/docker/ebash/history" \
        ".work/docker/ebash/inspect" \

    etestmsg "Validating Docker Image was NOT built"
    image="$(cat .work/docker/ebash/image)"
    etestmsg "$(lval image)"
    assert_docker_image_not_exists "${image}"
}

# Verify that provided build args are interpolated
ETEST_docker_build_args()
{
    etestmsg "Creating Dockerfile"
	cat <<-'END' >Dockerfile
	FROM alpine:edge
	ARG ARTIST
	ARG SONG
	RUN echo "${ARTIST}/${SONG}"
	END
    cat Dockerfile

    etestmsg "Building docker image (pretend)"
    $(tryrc docker_build           \
        --pretend                  \
        --name "elibs/ebash"       \
        --build-arg "ARTIST=James" \
        --build-arg "SONG=Laid"    \
    )
    assert_eq 1 "${rc}"

    etestmsg "Validating docker_build artifacts"
    assert_exists \
        ".work/docker/ebash/dockerfile" \
        ".work/docker/ebash/sha"        \
        ".work/docker/ebash/sha.func"   \
        ".work/docker/ebash/sha.short"  \
        ".work/docker/ebash/sha.detail" \

    etestmsg "Validating provided BUILD_ARGS are interpolated"
    assert_false diff "Dockerfile"            ".work/docker/ebash/dockerfile"
    assert_false grep "ARG ARTIST"            ".work/docker/ebash/dockerfile"
    assert_false grep "ARG SONG"              ".work/docker/ebash/dockerfile"
    assert_true  grep 'RUN echo "James/Laid"' ".work/docker/ebash/dockerfile"
}

# Verify that missing build args are NOT interpolated
ETEST_docker_build_args_missing()
{
    etestmsg "Creating Dockerfile"
	cat <<-END >Dockerfile
	FROM alpine:edge
	ARG UPR
	END
    cat Dockerfile

    etestmsg "Building docker image (pretend)"
    $(tryrc docker_build     \
        --pretend            \
        --name "elibs/ebash" \
    )
    assert_eq 1 "${rc}"

    etestmsg "Validating docker_build artifacts"
    assert_exists \
        ".work/docker/ebash/dockerfile" \
        ".work/docker/ebash/sha"        \
        ".work/docker/ebash/sha.func"   \
        ".work/docker/ebash/sha.short"  \
        ".work/docker/ebash/sha.detail" \

    etestmsg "Validating missing BUILD_ARGS are not interpolated"
    diff "Dockerfile" ".work/docker/ebash/dockerfile"
}

ETEST_docker_build_cache_from()
{
    etestmsg "Creating Dockerfile"
	cat <<-END >Dockerfile
	FROM alpine:edge
	ENV CREATOR etest-$$
	END
    cat Dockerfile

    etestmsg "Building docker image"
    docker_build --name "elibs/ebash" --cache-from "alpine:latest"

    etestmsg "Validating docker_build artifacts"
    assert_exists \
        ".work/docker/ebash/build.log"  \
        ".work/docker/ebash/dockerfile" \
        ".work/docker/ebash/history"    \
        ".work/docker/ebash/image"      \
        ".work/docker/ebash/inspect"    \
        ".work/docker/ebash/options"    \
        ".work/docker/ebash/sha"        \
        ".work/docker/ebash/sha.func"   \
        ".work/docker/ebash/sha.short"  \
        ".work/docker/ebash/sha.detail" \

    etestmsg "Validating Docker Image was built"
    image="$(cat .work/docker/ebash/image)"
    etestmsg "$(lval image)"
    trap_add "docker rmi ${image}"

    assert_docker_image_exists "${image}"
}

# Custom dockerfile name
ETEST_docker_build_custom_dockerfile()
{
    local file="Dockerfile.foobar"
    etestmsg "Creating Dockerfile=${file}"
	cat <<-END >${file}
	FROM alpine:edge
	ENV CREATOR etest-$$
	END
    cat "${file}"

    etestmsg "Building docker image"
    docker_build             \
        --name "elibs/ebash" \
        --file "${file}"

    etestmsg "Validating docker_build artifacts"
    assert_exists \
        ".work/docker/ebash/build.log"  \
        ".work/docker/ebash/dockerfile" \
        ".work/docker/ebash/history"    \
        ".work/docker/ebash/image"      \
        ".work/docker/ebash/inspect"    \
        ".work/docker/ebash/options"    \
        ".work/docker/ebash/sha"        \
        ".work/docker/ebash/sha.func"   \
        ".work/docker/ebash/sha.short"  \
        ".work/docker/ebash/sha.detail" \

    etestmsg "Validating Docker Image was built"
    image="$(cat .work/docker/ebash/image)"
    etestmsg "$(lval image)"
    trap_add "docker rmi ${image}"

    assert_docker_image_exists "${image}"
}

# Custom dockerfile and custom artifact name
ETEST_docker_build_custom_dockerfile()
{
    local file="Dockerfile.foobar"
    etestmsg "Creating Dockerfile=${file}"
	cat <<-END >${file}
	FROM alpine:edge
	ENV CREATOR etest-$$
	END
    cat "${file}"

    etestmsg "Building docker image"
    docker_build                   \
        --name "elibs_ebash"       \
        --file "${file}"

    etestmsg "Validating docker_build artifacts"
    assert_exists \
        ".work/docker/elibs_ebash/build.log"  \
        ".work/docker/elibs_ebash/dockerfile" \
        ".work/docker/elibs_ebash/history"    \
        ".work/docker/elibs_ebash/image"      \
        ".work/docker/elibs_ebash/inspect"    \
        ".work/docker/elibs_ebash/options"    \
        ".work/docker/elibs_ebash/sha"        \
        ".work/docker/elibs_ebash/sha.func"   \
        ".work/docker/elibs_ebash/sha.short"  \
        ".work/docker/elibs_ebash/sha.detail" \

    etestmsg "Validating Docker Image was built"
    image="$(cat .work/docker/elibs_ebash/image)"
    etestmsg "$(lval image)"
    trap_add "docker rmi ${image}"

    assert_docker_image_exists "${image}"
}

ETEST_docker_custom_shafunc()
{
    etestmsg "Creating Dockerfile"
	cat <<-END >Dockerfile
	FROM alpine:edge
	ENV CREATOR etest-$$
	END
    cat Dockerfile

    etestmsg "Building docker image"
    docker_build             \
        --name "elibs/ebash" \
        --shafunc sha512

    assert_eq "sha512" "$(cat .work/docker/ebash/sha.func)"

    etestmsg "Validating docker_build artifacts"
    assert_exists \
        ".work/docker/ebash/build.log"  \
        ".work/docker/ebash/dockerfile" \
        ".work/docker/ebash/history"    \
        ".work/docker/ebash/image"      \
        ".work/docker/ebash/inspect"    \
        ".work/docker/ebash/options"    \
        ".work/docker/ebash/sha"        \
        ".work/docker/ebash/sha.func"   \
        ".work/docker/ebash/sha.short"  \
        ".work/docker/ebash/sha.detail" \

    etestmsg "Validating Docker Image was built"
    image="$(cat .work/docker/ebash/image)"
    etestmsg "$(lval image)"
    trap_add "docker rmi ${image}"

    assert_docker_image_exists "${image}"
}

# Verify we can provide multiple additional tags and that all get created
ETEST_docker_build_tags()
{
    etestmsg "Creating Dockerfile"
	cat <<-END >Dockerfile
	FROM alpine:edge
	ENV CREATOR etest-$$
	END
    cat Dockerfile

    local tags=(
        "elibs/ebash:etest-$$-tag1"
        "elibs/ebash:etest-$$-tag2"
        "elibs/ebash-cicd:$$"
        "foo"
        "bar"
        "zap"
    )

    etestmsg "Building docker image"
    eval "docker_build --name elibs/ebash $(array_join --before tags ' --tag ')"
    trap_add "docker rmi ${tags[*]}"

    etestmsg "Validating docker_build artifacts"
    assert_exists \
        ".work/docker/ebash/build.log"  \
        ".work/docker/ebash/dockerfile" \
        ".work/docker/ebash/history"    \
        ".work/docker/ebash/image"      \
        ".work/docker/ebash/inspect"    \
        ".work/docker/ebash/options"    \
        ".work/docker/ebash/sha"        \
        ".work/docker/ebash/sha.func"   \
        ".work/docker/ebash/sha.short"  \
        ".work/docker/ebash/sha.detail" \

    etestmsg "Validating Docker Image was built"
    image="$(cat .work/docker/ebash/image)"
    etestmsg "$(lval image)"
    trap_add "docker rmi ${image}"
    assert_docker_image_exists "${image}"

    etestmsg "Validating all tags were built"
    for tag in ${tags[@]}; do
        echo "${tag}"
        assert_docker_image_exists "${tag}"
    done
}

# Verify pushing tags works properly. Mock out docker() so that we don't have to actually have an upstream to push to.
ETEST_docker_build_tags_push()
{
    etestmsg "Creating Dockerfile"
	cat <<-END >Dockerfile
	FROM alpine:edge
	ENV CREATOR etest-$$
	END
    cat Dockerfile

    local tags=(
        "elibs/ebash:etest-$$-tag1"
        "elibs/ebash:etest-$$-tag2"
        "elibs/ebash-cicd:$$"
        "foo"
        "bar"
        "zap"
    )

    etestmsg "Building docker image"
    eval "docker_build --name elibs/ebash --username neo --password matrix $(array_join --before tags ' --tag ') --push"

    etestmsg "Validating docker_build artifacts"
    assert_exists \
        ".work/docker/ebash/build.log"  \
        ".work/docker/ebash/dockerfile" \
        ".work/docker/ebash/history"    \
        ".work/docker/ebash/image"      \
        ".work/docker/ebash/inspect"    \
        ".work/docker/ebash/options"    \
        ".work/docker/ebash/sha"        \
        ".work/docker/ebash/sha.func"   \
        ".work/docker/ebash/sha.short"  \
        ".work/docker/ebash/sha.detail" \

    etestmsg "Validating Docker Image was built"
    image="$(cat .work/docker/ebash/image)"
    etestmsg "$(lval image)"
    trap_add "docker rmi ${image}"
    assert_docker_image_exists "${image}"

    etestmsg "Validating all tags were built"
    for tag in ${tags[@]}; do
        echo "${tag}"
        assert_docker_image_exists "${tag}"
    done

    etestmsg "Validating all tags were pushed"
    array_sort tags
    array_sort docker_tags_pushed
    etestmsg "$(lval tags docker_tags_pushed)"
    for tag in ${tags[@]}; do
        array_contains docker_tags_pushed "${tag}"
    done
}

# Verify if we create the same docker image multiple times in a row that it does NOT build it again but instead reuses
# the one we've locally built.
ETEST_docker_build_twice()
{
    etestmsg "Creating Dockerfile"
	cat <<-END >Dockerfile
	FROM alpine:edge
	ENV CREATOR etest-$$
	END
    cat Dockerfile

    etestmsg "Building docker image"
    docker_build --name "elibs/ebash"

    etestmsg "Validating docker_build artifacts"
    assert_exists \
        ".work/docker/ebash/build.log"  \
        ".work/docker/ebash/dockerfile" \
        ".work/docker/ebash/history"    \
        ".work/docker/ebash/image"      \
        ".work/docker/ebash/inspect"    \
        ".work/docker/ebash/options"    \
        ".work/docker/ebash/sha"        \
        ".work/docker/ebash/sha.detail" \
        ".work/docker/ebash/sha.func"   \
        ".work/docker/ebash/sha.short"  \

    etestmsg "Validating Docker Image was built"
    image="$(cat .work/docker/ebash/image)"
    etestmsg "$(lval image)"
    assert_docker_image_exists "${image}"
    trap_add "docker rmi ${image}"

    for part in build.log dockerfile history image inspect sha sha.short sha.detail; do
        cp ".work/docker/ebash/${part}" ".work/docker/ebash/${part}.orig"
    done
    grep 'pretend="0"' ".work/docker/ebash/options"

    etestmsg "Building docker image (AGAIN)"
    docker_build         \
        --pretend        \
        --name "elibs/ebash"

    for part in build.log dockerfile history image inspect sha sha.short sha.detail; do
        etestmsg "Checking ${part}"
        # Depending on how fast this test runs, the output may say '1 second ago' or '2 seconds ago' which can cause
        # a false-positive failure. We don't actually care about that part of the history file so just remove it from
        # both files before we diff.
        if [[ "${part}" == "history" ]]; then

            diff ".work/docker/ebash/${part}.orig" ".work/docker/ebash/${part}" || true

            sed -i -e 's|[0-9]\+ seconds* ago\s*|1 second ago        |' \
                   -e 's|Less than a second ago\s*|1 second ago        |' \
                ".work/docker/ebash/${part}.orig" ".work/docker/ebash/${part}"
        fi

        diff ".work/docker/ebash/${part}.orig" ".work/docker/ebash/${part}"
    done
    grep 'pretend="1"' ".work/docker/ebash/options"

    created_expect=$(jq --raw-output '.[].Created' ".work/docker/ebash/inspect")
    created_actual=$(docker inspect --type image ${image} | jq --raw-output '.[].Created')
    assert_eq "${created_expect}" "${created_actual}"
}

# Verify if we make a small change to the Dockerfile that we won't reuse the previously built image.
ETEST_docker_build_twice_changed()
{
    etestmsg "Creating Dockerfile"
	cat <<-END >Dockerfile
	FROM alpine:edge
	ENV CREATOR etest-$$
	END
    cat Dockerfile

    etestmsg "Building docker image"
    docker_build --name "elibs/ebash"

    etestmsg "Validating docker_build artifacts"
    assert_exists                       \
        ".work/docker/ebash/build.log"  \
        ".work/docker/ebash/dockerfile" \
        ".work/docker/ebash/history"    \
        ".work/docker/ebash/image"      \
        ".work/docker/ebash/inspect"    \
        ".work/docker/ebash/options"    \
        ".work/docker/ebash/sha"        \
        ".work/docker/ebash/sha.func"   \
        ".work/docker/ebash/sha.short"  \
        ".work/docker/ebash/sha.detail" \

    etestmsg "Validating Docker Image was built"
    image="$(cat .work/docker/ebash/image)"
    etestmsg "$(lval image)"
    assert_docker_image_exists "${image}"
    trap_add "docker rmi ${image}"

    for part in dockerfile sha sha.short sha.detail; do
        cp ".work/docker/ebash/${part}" ".work/docker/ebash/${part}.orig"
    done

    etestmsg "Modifying Dockerfile"
    cat <<-END >Dockerfile
	FROM alpine:edge
	ENV CREATOR etest-$$
	ENV TIMESTAMP $(etimestamp)
	END
    cat Dockerfile

    etestmsg "Building docker image (AGAIN)"
    $(tryrc docker_build     \
        --pretend            \
        --name "elibs/ebash" \
    )

    assert_eq 1 "${rc}"

    for part in dockerfile sha sha.short sha.detail; do
        assert_false diff ".work/docker/ebash/${part}.orig" ".work/docker/ebash/${part}"
    done
}

ETEST_docker_build_overlay()
{
    etestmsg "Creating Dockerfile"
	cat <<-END >Dockerfile
	FROM ubuntu:20.04
	ENV CREATOR etest-$$
	ENTRYPOINT ["sleep", "infinity"]
	END
    cat Dockerfile

    mkdir -p "overlay/usr/local/bin" "overlay/etc"
    touch "overlay/usr/local/bin/foo"
    touch "overlay/etc/foo.cfg"

    etestmsg "Building docker image"
    docker_build \
        --name "elibs/ebash" \
        --overlay ebash      \
        --overlay systemd    \
        --overlay selinux    \
        --overlay rsyslog    \
        --overlay-tree overlay

    cat ".work/docker/ebash/dockerfile"

    etestmsg "Validating options file"
    cat ".work/docker/ebash/options"
    options_lines=(
        'build_arg=()'
        'cache_from=""'
        'file="Dockerfile"'
        'name="elibs/ebash"'
        'overlay=("ebash" "systemd" "selinux" "rsyslog")'
        'overlay_tree="overlay"'
        'password=""'
        'pretend="0"'
        'pull="0"'
        'push="0"'
        'registry="https://index.docker.io/v1/"'
        'shafunc="sha256"'
        'tag=()'
        'username=""'
        'workdir=".work/docker"'
    )

    diff --unified <(echo "$(array_join_nl options_lines)") ".work/docker/ebash/options"

    local overdir=".work/docker/ebash/overlay"
    etestmsg "Inspecting $(lval overdir)"
    find "${overdir}" -ls
    assert_exists "${overdir}/custom"
    assert_exists "${overdir}/ebash"
    assert_exists "${overdir}/systemd"
    assert_exists "${overdir}/selinux"
    assert_exists "${overdir}/rsyslog"

    etestmsg "Validating dockerfile COPY directives"
    grep 'COPY "'${overdir}'/custom" "/"'  ".work/docker/ebash/dockerfile"
    grep 'COPY "'${overdir}'/ebash" "/"'   ".work/docker/ebash/dockerfile"
    grep 'COPY "'${overdir}'/systemd" "/"' ".work/docker/ebash/dockerfile"
    grep 'COPY "'${overdir}'/selinux" "/"' ".work/docker/ebash/dockerfile"
    grep 'COPY "'${overdir}'/rsyslog" "/"' ".work/docker/ebash/dockerfile"

    etestmsg "Validating overlay entries in depends_sha"
    grep "${overdir}/custom/usr/local/bin/foo"          ".work/docker/ebash/sha.detail"
    grep "${overdir}/custom/etc/foo.cfg"                ".work/docker/ebash/sha.detail"
    grep "${overdir}/ebash"                             ".work/docker/ebash/sha.detail"
    grep "${overdir}/selinux/etc/selinux/config"        ".work/docker/ebash/sha.detail"
    grep "${overdir}/systemd/usr/local/bin/systemctl"   ".work/docker/ebash/sha.detail"
    grep "${overdir}/systemd/usr/local/bin/timedatectl" ".work/docker/ebash/sha.detail"
    grep "${overdir}/rsyslog/etc/rsyslog.conf"          ".work/docker/ebash/sha.detail"

    etestmsg "Validating overlay contents inside docker image"
    image="$(cat .work/docker/ebash/image)"
    container_id=$(docker run --detach --network host "${image}")
    trap_add "docker kill ${container_id}"

    validate_paths=(
        "/etc/foo.cfg"
        "/etc/rsyslog.conf"
        "/etc/selinux/config"
        "/opt/ebash"
        "/opt/ebash/bin/ebash"
        "/opt/ebash/bin/einfo"
        "/usr/local/bin/ebash"
        "/usr/local/bin/foo"
        "/usr/local/bin/systemctl"
        "/usr/local/bin/timedatectl"
    )

    for entry in ${validate_paths[@]}; do
        echo "${entry}"
        docker exec "${container_id}" bash -c "[[ -e ${entry} ]]"
    done
}

ETEST_docker_build_overlay_systemctl_wrapper()
{
    EDEBUG=daemon

    etestmsg "Creating init"
	cat <<-'END' >init
	#!/bin/bash

	$(ebash --source)

	EDEBUG=daemon

	# Block all signals that would otherwise cause us to exit similar to real 'init'
	disable_signals

	daemon_init sleeper1 \
	    autostart="yes"  \
	    cmdline="sleep infinity"

	daemon_init sleeper2 \
	    autostart="yes"  \
	    cmdline="sleep infinity"

	# Process reaping
	while true; do
		wait
	done
	END
    cat init
    chmod +x init

    etestmsg "Creating Dockerfile"
	cat <<-END >Dockerfile
	FROM ubuntu:20.04
	COPY "init" "/init"
	ENTRYPOINT ["/init"]
	END
    cat Dockerfile

    etestmsg "Building docker image"
    docker_build \
        --name "elibs/ebash"                   \
        --file "${TEST_DIR_OUTPUT}/Dockerfile" \
        --overlay "ebash"                      \
        --overlay "systemd"
    cat ".work/docker/ebash/dockerfile"
    find ".work/docker/ebash/overlay" -ls

    etestmsg "Running docker container"
    image="$(cat .work/docker/ebash/image)"
    container_id=$(docker run --detach --network host "${image}")
    trap_add "docker kill ${container_id}"
    eretry --max-timeout 30s docker exec "${container_id}" bash -c "[[ -e /usr/local/bin/systemctl ]]"

    etestmsg "Validate systemctl wrapper"
    docker exec "${container_id}" systemctl status sleeper1
    docker exec "${container_id}" systemctl is-active sleeper1
    docker exec "${container_id}" systemctl status sleeper2
    docker exec "${container_id}" systemctl is-active sleeper2

    etestmsg "Stopping sleeper1 and sleeper2"
    docker exec "${container_id}" systemctl stop sleeper1
    docker exec "${container_id}" systemctl stop sleeper2
    assert_false docker exec "${container_id}" systemctl status sleeper1
    assert_false docker exec "${container_id}" systemctl status sleeper2

    etestmsg "Starting sleeper1"
    docker exec "${container_id}" systemctl start sleeper1
    eretry --max-timeout 30s docker exec "${container_id}" systemctl status sleeper1

    etestmsg "Restarting sleeper1"
    docker exec "${container_id}" systemctl restart sleeper1
    eretry --max-timeout 30s docker exec "${container_id}" systemctl status sleeper1

    etestmsg "Restarting sleeper2"
    docker exec "${container_id}" systemctl restart sleeper2
    eretry --max-timeout 30s docker exec "${container_id}" systemctl status sleeper2
}

ETEST_docker_depends_sha()
{
    etestmsg "Creating Dockerfile"
	cat <<-END >Dockerfile
	FROM alpine:edge
	ENV CREATOR etest-$$
	END
    cat Dockerfile

    mkdir -p "overlay/usr/local/bin" "overlay/etc"
    touch "overlay/usr/local/bin/foo"
    touch "overlay/etc/foo.cfg"

    etestmsg "Computing Dependency SHA"
    docker_depends_sha \
        --name "elibs/ebash" \
        --overlay systemd    \
        --overlay selinux    \
        --overlay rsyslog    \
        --overlay-tree overlay

    cat ".work/docker/ebash/dockerfile"

    etestmsg "Validating depends_sha artifacts"
    assert_exists \
        ".work/docker/ebash/dockerfile" \
        ".work/docker/ebash/options"    \
        ".work/docker/ebash/sha"        \
        ".work/docker/ebash/sha.func"   \
        ".work/docker/ebash/sha.short"  \
        ".work/docker/ebash/sha.detail" \

    etestmsg "Validating Docker Image was not built"
    image="elibs/ebash:$(cat .work/docker/ebash/sha.short)"
    etestmsg "$(lval image)"
    assert_docker_image_not_exists "${image}"

    # Validate dependency SHA
    etestmsg "Validating SHA function"
    assert_eq "sha256" "$(cat .work/docker/ebash/sha.func)"
    cat ".work/docker/ebash/sha"

    etestmsg "Details"
    cat ".work/docker/ebash/sha.detail"
    depends=(
        ".work/docker/ebash/dockerfile"
        ".work/docker/ebash/overlay/custom/etc/foo.cfg"
        ".work/docker/ebash/overlay/custom/usr/local/bin/foo"
        ".work/docker/ebash/overlay/rsyslog/etc/rsyslog.conf"
        ".work/docker/ebash/overlay/selinux/etc/selinux/config"
        ".work/docker/ebash/overlay/systemd/usr/local/bin/systemctl"
        ".work/docker/ebash/overlay/systemd/usr/local/bin/timedatectl"
    )

    etestmsg "Showing local dependency tree"
    find ".work/docker/ebash/overlay"

    expect=()
    for depend in ${depends[@]}; do
        expect+=( "${depend}@sha256:$(sha256sum "${depend}" | awk '{print $1}')" )
    done

    etestmsg "Expected SHA Details"
    expected=$(array_join_nl expect)
    assert_eq "${expected}" "$(cat .work/docker/ebash/sha.detail)"

    etestmsg "Roll-up SHA"
    expected=$(sha256sum .work/docker/ebash/sha.detail | awk '{print $1}')
    assert_eq "sha256:${expected}" "$(cat .work/docker/ebash/sha)"
}

ETEST_docker_depends_sha_exclude()
{
    etestmsg "Creating Dockerfile"
	cat <<-END >Dockerfile
	FROM alpine:edge
	ENV CREATOR etest-$$
	COPY foo /foo
	END
    cat Dockerfile

    etestmsg "Creating dockerignore"
    mkdir foo foo/baz foo/null foo/null/work
    touch \
        foo/bar        \
        foo/zap        \
        foo/a.o        \
        foo/b.o        \
        foo/baz/README \
        foo/baz/dogs.o \
        foo/baz/cats.o \
        foo/null/a     \
        foo/null/b     \
        foo/null/work/ok
    echo '**/*.o'   >> .dockerignore
    echo 'foo/null' >> .dockerignore
    cat ".dockerignore"

    etestmsg "Computing Dependency SHA"
    docker_depends_sha \
        --name "elibs/ebash" \

    cat ".work/docker/ebash/dockerfile"

    etestmsg "Validating depends_sha artifacts"
    assert_exists \
        ".work/docker/ebash/dockerfile" \
        ".work/docker/ebash/options"    \
        ".work/docker/ebash/sha"        \
        ".work/docker/ebash/sha.func"   \
        ".work/docker/ebash/sha.short"  \
        ".work/docker/ebash/sha.detail" \

    etestmsg "Validating Docker Image was not built"
    image="elibs/ebash:$(cat .work/docker/ebash/sha.short)"
    etestmsg "$(lval image)"
    assert_docker_image_not_exists "${image}"

    # Validate dependency SHA
    etestmsg "Validating SHA function"
    assert_eq "sha256" "$(cat .work/docker/ebash/sha.func)"
    cat ".work/docker/ebash/sha"

    etestmsg "Details"
    cat ".work/docker/ebash/sha.detail"
    depends=(
        ".work/docker/ebash/dockerfile"
        "foo/bar"
        "foo/baz/README"
        "foo/zap"
    )

    etestmsg "Showing local dependency tree"
    find ".work/docker/ebash/overlay"

    expect=()
    for depend in ${depends[@]}; do
        expect+=( "${depend}@sha256:$(sha256sum "${depend}" | awk '{print $1}')" )
    done

    etestmsg "Expected SHA Details"
    expected=$(array_join_nl expect)
    assert_eq "${expected}" "$(cat .work/docker/ebash/sha.detail)"

    etestmsg "Roll-up SHA"
    expected=$(sha256sum .work/docker/ebash/sha.detail | awk '{print $1}')
    assert_eq "sha256:${expected}" "$(cat .work/docker/ebash/sha)"
}

ETEST_docker_export_tgz()
{
    unset docker

    etestmsg "Creating Dockerfile"
	cat <<-END >Dockerfile
	FROM alpine:edge
	ENV CREATOR etest-$$
	END
    cat Dockerfile

    etestmsg "Building docker image"
    docker_build --name "elibs/ebash"

    etestmsg "Validating Docker Image was built"
    image="$(cat .work/docker/ebash/image)"
    trap_add "docker rmi ${image} &>/dev/null || true"
    assert_docker_image_exists "${image}"

    etestmsg "Converting docker image to tgz"
    docker_export "${image}" image.tgz
}

ETEST_docker_export_squashfs()
{
    # This test only works on linux as it requires squashfs.
    if ! os Linux; then
        ewarn "Skipping ${FUNCNAME} on non-Linux OS."
        return 0
    fi

    unset docker

    etestmsg "Creating Dockerfile"
	cat <<-END >Dockerfile
	FROM alpine:edge
	ENV CREATOR etest-$$
	END
    cat Dockerfile

    etestmsg "Building docker image"
    docker_build --name "elibs/ebash"

    etestmsg "Validating Docker Image was built"
    image="$(cat .work/docker/ebash/image)"
    trap_add "docker rmi ${image} &>/dev/null || true"
    assert_docker_image_exists "${image}"

    etestmsg "Converting docker image to squashfs"
    docker_export "${image}" image.squashfs
}
