#!/usr/bin/env bash
#
# Copyright 2011-2018, Marshall McMullen <marshall.mcmullen@gmail.com>
# Copyright 2011-2018, SolidFire, Inc. All rights reserved.
#
# This program is free software: you can redistribute it and/or modify it under the terms of the Apache License
# as published by the Apache Software Foundation, either version 2 of the License, or (at your option) any later
# version.

[[ ${__EBASH_OS} == Linux ]] || return 0

BANNER_WIDTH=50
ARCHIVE_TYPES=(
    squashfs
    iso
    tar
    tar.gz
    tlz
    cpio
    cgz
    cxz
)

ETEST_archive_compress_program()
{
    assert_empty "$(archive_compress_program foobar)"
    assert_empty "$(archive_compress_program tarfoo)"
    assert_empty "$(archive_compress_program foo.squashfs)"
    assert_empty "$(archive_compress_program foo.tar)"
    assert_empty "$(archive_compress_program foo.iso)"
    assert_empty "$(archive_compress_program foo.cpio)"
    assert_match "$(archive_compress_program foo.tbz2)"       "bzip2|lbzip2|pbzip2"
    assert_match "$(archive_compress_program foo.tar.gz)"     "gzip|pigz"
    assert_match "$(archive_compress_program foo.cgz)"        "gzip|pigz"
    assert_match "$(archive_compress_program foo.cxz)"        "lzma|xz"
    assert_match "$(archive_compress_program foo.tar.xz)"     "lzma|xz"
    assert_match "$(archive_compress_program foo.tar.lz)"     "lzma|xz"
}

ETEST_archive_suffixes()
{
    assert_eq ".squashfs" "$(archive_suffixes squashfs)"
    assert_eq ".iso"      "$(archive_suffixes iso)"

    assert_eq ".tar .tar.gz .tgz .taz .tar.bz2 .tz2 .tbz2 .tbz .tar.xz .txz .tar.lz .tlz" \
        "$(archive_suffixes tar)"

    assert_eq ".cpio .cpio.gz .cgz .caz .cpio.bz2 .cz2 .cbz2 .cbz .cpio.xz .cxz .cpio.lz .clz" \
        "$(archive_suffixes cpio)"

    assert_eq ".squashfs .iso .tar .tar.gz .tgz .taz .tar.bz2 .tz2 .tbz2 .tbz .tar.xz .txz .tar.lz .tlz .cpio .cpio.gz .cgz .caz .cpio.bz2 .cz2 .cbz2 .cbz .cpio.xz .cxz .cpio.lz .clz" \
        "$(archive_suffixes squashfs iso tar cpio)"

    assert_false archive_suffixes invalid
}

ETEST_archive_suffixes_wildcard()
{
    assert_eq "*.squashfs" "$(archive_suffixes --wildcard squashfs)"
    assert_eq "*.iso"      "$(archive_suffixes --wildcard iso)"

    assert_eq "*.tar *.tar.gz *.tgz *.taz *.tar.bz2 *.tz2 *.tbz2 *.tbz *.tar.xz *.txz *.tar.lz *.tlz" \
        "$(archive_suffixes --wildcard tar)"

    assert_eq "*.cpio *.cpio.gz *.cgz *.caz *.cpio.bz2 *.cz2 *.cbz2 *.cbz *.cpio.xz *.cxz *.cpio.lz *.clz" \
        "$(archive_suffixes --wildcard cpio)"

    assert_eq "*.squashfs *.iso *.tar *.tar.gz *.tgz *.taz *.tar.bz2 *.tz2 *.tbz2 *.tbz *.tar.xz *.txz *.tar.lz *.tlz *.cpio *.cpio.gz *.cgz *.caz *.cpio.bz2 *.cz2 *.cbz2 *.cbz *.cpio.xz *.cxz *.cpio.lz *.clz" \
        "$(archive_suffixes --wildcard squashfs iso tar cpio)"
}

ETEST_archive_suffixes_pattern_list()
{
    assert_eq ".squashfs" "$(archive_suffixes --pattern squashfs)"
    assert_eq ".iso"      "$(archive_suffixes --pattern iso)"

    assert_eq ".tar|.tar.gz|.tgz|.taz|.tar.bz2|.tz2|.tbz2|.tbz|.tar.xz|.txz|.tar.lz|.tlz" \
        "$(archive_suffixes --pattern tar)"

    assert_eq ".cpio|.cpio.gz|.cgz|.caz|.cpio.bz2|.cz2|.cbz2|.cbz|.cpio.xz|.cxz|.cpio.lz|.clz" \
        "$(archive_suffixes --pattern cpio)"

    assert_eq ".squashfs|.iso|.tar|.tar.gz|.tgz|.taz|.tar.bz2|.tz2|.tbz2|.tbz|.tar.xz|.txz|.tar.lz|.tlz|.cpio|.cpio.gz|.cgz|.caz|.cpio.bz2|.cz2|.cbz2|.cbz|.cpio.xz|.cxz|.cpio.lz|.clz" \
        "$(archive_suffixes --pattern squashfs iso tar cpio)"
}

ETEST_archive_suffixes_pattern_list_wildcard()
{
    assert_eq "*.squashfs" "$(archive_suffixes --pattern --wildcard squashfs)"
    assert_eq "*.iso"      "$(archive_suffixes --pattern --wildcard iso)"

    assert_eq "*.tar|*.tar.gz|*.tgz|*.taz|*.tar.bz2|*.tz2|*.tbz2|*.tbz|*.tar.xz|*.txz|*.tar.lz|*.tlz" \
        "$(archive_suffixes --pattern --wildcard tar)"

    assert_eq "*.cpio|*.cpio.gz|*.cgz|*.caz|*.cpio.bz2|*.cz2|*.cbz2|*.cbz|*.cpio.xz|*.cxz|*.cpio.lz|*.clz" \
        "$(archive_suffixes --pattern --wildcard cpio)"

    assert_eq "*.squashfs|*.iso|*.tar|*.tar.gz|*.tgz|*.taz|*.tar.bz2|*.tz2|*.tbz2|*.tbz|*.tar.xz|*.txz|*.tar.lz|*.tlz|*.cpio|*.cpio.gz|*.cgz|*.caz|*.cpio.bz2|*.cz2|*.cbz2|*.cbz|*.cpio.xz|*.cxz|*.cpio.lz|*.clz" \
        "$(archive_suffixes --pattern --wildcard squashfs iso tar cpio)"
}

ETEST_archive_create()
{
    local idx=0
    for idx in $(array_indexes ARCHIVE_TYPES); do
        local ftype="${ARCHIVE_TYPES[$idx]}"
        COLUMNS=${BANNER_WIDTH} ebanner "${ftype} ($((idx+1))/${#ARCHIVE_TYPES[@]})"

        etestmsg "Populating source directory"
        efreshdir src
        touch src/{file1,file2}

        etestmsg "Creating dest.${ftype}"
        archive_create dest.${ftype} src
        archive_list dest.${ftype}
        assert_archive_contents dest.${ftype} src src/file1 src/file2

        # Verify source files still exist since we did not specify --delete
        assert_exists src src/file1 src/file2
    done
}

ETEST_archive_create_type()
{
    etestmsg "Populating source directory"
    efreshdir src
    touch src/{file1,file2}

    etestmsg "Creating dest.img (cpio)"
    archive_create -t=cpio dest.img src
    assert_match "$(file dest.img)" "ASCII cpio archive"
    archive_list -t=cpio dest.img

    etestmsg "Creating dest.img (cgz)"
    archive_create -t=cgz dest.img src
    assert_match "$(file dest.img)" "gzip compressed data"
    archive_list -t=cgz dest.img
}

ETEST_archive_create_delete()
{
    local idx=0
    for idx in $(array_indexes ARCHIVE_TYPES); do
        local ftype="${ARCHIVE_TYPES[$idx]}"
        COLUMNS=${BANNER_WIDTH} ebanner "${ftype} ($((idx+1))/${#ARCHIVE_TYPES[@]})"

        etestmsg "Populating source directory"
        efreshdir src
        touch src/{file1,file2}

        etestmsg "Creating dest.${ftype}"
        archive_create --delete dest.${ftype} src
        assert_archive_contents dest.${ftype} src src/file1 src/file2

        etestmsg "Ensuring source files were deleted"
        assert_not_exists src src/file1 src/file2
    done
}

ETEST_archive_create_delete_contents()
{
    local idx=0
    for idx in $(array_indexes ARCHIVE_TYPES); do
        local ftype="${ARCHIVE_TYPES[$idx]}"
        COLUMNS=${BANNER_WIDTH} ebanner "${ftype} ($((idx+1))/${#ARCHIVE_TYPES[@]})"

        etestmsg "Populating source directory"
        efreshdir src
        touch src/{file1,file2}

        etestmsg "Creating dest.${ftype}"
        archive_create --delete dest.${ftype} src/.
        assert_archive_contents dest.${ftype} file1 file2

        etestmsg "Ensuring source files were deleted"
        assert_not_exists src src/file1 src/file2
    done
}

ETEST_archive_create_symlinks()
{
    local idx=0
    for idx in $(array_indexes ARCHIVE_TYPES); do
        local ftype="${ARCHIVE_TYPES[$idx]}"
        COLUMNS=${BANNER_WIDTH} ebanner "${ftype} ($((idx+1))/${#ARCHIVE_TYPES[@]})"

        etestmsg "Populating source directory"
        efreshdir src
        touch src/{file1,file2}
        mkdir src/dir1
        echo "foo" > foo
        ln -s ./foo  src/filelnk
        ln -s ./dir1 src/dirlnk
        find src -ls

        etestmsg "Creating dest.${ftype}"
        archive_create dest.${ftype} src
        assert_archive_contents dest.${ftype} src src/dir1 src/dirlnk src/filelnk src/file1 src/file2

        etestmsg "Ensuring symlinks preserved"
        archive_extract dest.${ftype} dest
        [[ -L dest/src/filelnk ]]
        [[ -L dest/src/dirlnk  ]]
    done
}

ETEST_archive_create_symlinks_contents()
{
    local idx=0
    for idx in $(array_indexes ARCHIVE_TYPES); do
        local ftype="${ARCHIVE_TYPES[$idx]}"
        COLUMNS=${BANNER_WIDTH} ebanner "${ftype} ($((idx+1))/${#ARCHIVE_TYPES[@]})"

        etestmsg "Populating source directory with symlinks"
        efreshdir src
        touch src/{file1,file2}
        echo "foo" > foo
        ln -s ${PWD}/foo src/filelnk
        ln -s ${PWD}/.   src/dirlnk
        find src -ls

        etestmsg "Creating dest.${ftype}"
        archive_create dest.${ftype} src/.
        assert_archive_contents dest.${ftype} filelnk file1 file2 dirlnk

        etestmsg "Ensuring symlinks preserved"
        archive_extract dest.${ftype} dest
        [[ -L dest/filelnk ]]
        [[ -L dest/dirlnk  ]]
    done
}

ETEST_archive_create_symlinks_dereference_not_supported()
{
    local idx=0
    for idx in $(array_indexes ARCHIVE_TYPES); do
        local ftype="${ARCHIVE_TYPES[$idx]}"
        COLUMNS=${BANNER_WIDTH} ebanner "${ftype} ($((idx+1))/${#ARCHIVE_TYPES[@]})"

        # --dereference flag only supported for tar formats.
        if [[ $(archive_type "dest.${ftype}") == "tar" ]]; then
            continue
        fi

        etestmsg "Creating dest.${ftype} (should fail)"
        mkdir -p src
        assert_false archive_create --dereference dest.${ftype} src
    done
}

ETEST_archive_create_symlinks_dereference()
{
    local idx=0
    LOCAL_ARCHIVE_TYPES=( tar tar.gz )
    for idx in $(array_indexes LOCAL_ARCHIVE_TYPES); do
        local ftype="${LOCAL_ARCHIVE_TYPES[$idx]}"
        COLUMNS=${BANNER_WIDTH} ebanner "${ftype} ($((idx+1))/${#LOCAL_ARCHIVE_TYPES[@]})"

        etestmsg "Populating source directory"
        efreshdir src
        touch src/{file1,file2}
        echo "foo" > foo
        ln -s ${PWD}/foo src/filelnk
        find src -ls

        etestmsg "Creating dest.${ftype}"
        archive_create --dereference dest.${ftype} src
        assert_archive_contents dest.${ftype} src src/filelnk src/file1 src/file2

        etestmsg "Ensuring symlinks preserved"
        archive_extract dest.${ftype} dest
        [[ ! -L dest/src/filelnk ]]
    done
}

ETEST_archive_create_level()
{
    local idx=0
    for idx in $(array_indexes ARCHIVE_TYPES); do
        local ftype="${ARCHIVE_TYPES[$idx]}"
        COLUMNS=${BANNER_WIDTH} ebanner "${ftype} ($((idx+1))/${#ARCHIVE_TYPES[@]})"

        etestmsg "Populating source directory"
        efreshdir src
        touch src/{file1,file2}

        etestmsg "Creating dest.${ftype}"
        archive_create --level 1 dest.${ftype} src
        assert_archive_contents dest.${ftype} src src/file1 src/file2
        rm dest.${ftype}

        archive_create --level 9 dest.${ftype} src
        assert_archive_contents dest.${ftype} src src/file1 src/file2
        rm dest.${ftype}

        archive_create --fast dest.${ftype} src
        assert_archive_contents dest.${ftype} src src/file1 src/file2
        rm dest.${ftype}

        archive_create --best dest.${ftype} src
        assert_archive_contents dest.${ftype} src src/file1 src/file2
        rm dest.${ftype}
    done
}

ETEST_archive_create_single_file()
{
    local idx=0
    for idx in $(array_indexes ARCHIVE_TYPES); do
        local ftype="${ARCHIVE_TYPES[$idx]}"
        COLUMNS=${BANNER_WIDTH} ebanner "${ftype} ($((idx+1))/${#ARCHIVE_TYPES[@]})"

        etestmsg "Populating source directory"
        efreshdir src
        cd src
        touch file1

        etestmsg "Creating dest.${ftype}"
        archive_create dest.${ftype} file1
        assert_archive_contents dest.${ftype} file1
    done
}

ETEST_archive_create_single_filetree()
{
    local idx=0
    for idx in $(array_indexes ARCHIVE_TYPES); do
        local ftype="${ARCHIVE_TYPES[$idx]}"
        COLUMNS=${BANNER_WIDTH} ebanner "${ftype} ($((idx+1))/${#ARCHIVE_TYPES[@]})"

        etestmsg "Populating source directory"
        efreshdir src
        mkdir -p src/sub1/sub2
        touch src/sub1/sub2/file1

        etestmsg "Creating dest.${ftype}"
        archive_create dest.${ftype} src/sub1/sub2/file1
        assert_archive_contents dest.${ftype} src src/sub1 src/sub1/sub2 src/sub1/sub2/file1
    done
}

ETEST_archive_create_directory_dot()
{
    local idx=0
    for idx in $(array_indexes ARCHIVE_TYPES); do
        local ftype="${ARCHIVE_TYPES[$idx]}"
        COLUMNS=${BANNER_WIDTH} ebanner "${ftype} ($((idx+1))/${#ARCHIVE_TYPES[@]})"

        etestmsg "Populating source directory"
        efreshdir src
        touch src/{file1,file2}

        etestmsg "Creating src.${ftype}"
        archive_create src.${ftype} src/.
        assert_archive_contents src.${ftype} file1 file2
    done
}

ETEST_archive_create_directory()
{
    local idx=0
    for idx in $(array_indexes ARCHIVE_TYPES); do
        local ftype="${ARCHIVE_TYPES[$idx]}"
        COLUMNS=${BANNER_WIDTH} ebanner "${ftype} ($((idx+1))/${#ARCHIVE_TYPES[@]})"

        etestmsg "Populating source directory"
        efreshdir src
        touch src/{file1,file2}

        etestmsg "Creating src.${ftype}"
        assert_not_exists DIR
        archive_create DIR/src.${ftype} src
        assert_archive_contents DIR/src.${ftype} src src/file1 src/file2
        rm -rf DIR
    done
}

ETEST_archive_create_files()
{
    local idx=0
    for idx in $(array_indexes ARCHIVE_TYPES); do
        local ftype="${ARCHIVE_TYPES[$idx]}"
        COLUMNS=${BANNER_WIDTH} ebanner "${ftype} ($((idx+1))/${#ARCHIVE_TYPES[@]})"

        etestmsg "Creating files"
        touch {file1,file2,file3,file4}

        etestmsg "Creating src.${ftype}"
        archive_create src.${ftype} file1 file2 file3 file4
        assert_archive_contents src.${ftype} file1 file2 file3 file4

        rm --force src.${ftype}
    done
}

ETEST_archive_create_missing_files()
{
    local idx=0
    for idx in $(array_indexes ARCHIVE_TYPES); do
        local ftype="${ARCHIVE_TYPES[$idx]}"
        COLUMNS=${BANNER_WIDTH} ebanner "${ftype} ($((idx+1))/${#ARCHIVE_TYPES[@]})"

        etestmsg "Creating files"
        touch {file1,file2,file3,file4}

        etestmsg "Creating src.${ftype} (should do nothing)"
        archive_create -i src.${ftype} NOT1 NOT2
        assert_not_exists src.${ftype}

        etestmsg "Creating src.${ftype} (should fail)"
        assert_false archive_create src.${ftype} NOT1 file1 file2 file3 file4 NOT2
        #BUG: assert_not_exists src.${ftype}

        etestmsg "Creating src.${ftype} (ignoring missing files -- should pass)"
        archive_create -i src.${ftype} NOT1 file1 file2 file3 file4 NOT2
        assert_archive_contents src.${ftype} file1 file2 file3 file4

        rm src.${ftype}
    done
}

ETEST_archive_create_mixed_files_directories()
{
    local idx=0
    for idx in $(array_indexes ARCHIVE_TYPES); do
        local ftype="${ARCHIVE_TYPES[$idx]}"
        COLUMNS=${BANNER_WIDTH} ebanner "${ftype} ($((idx+1))/${#ARCHIVE_TYPES[@]})"

        etestmsg "Populating source directory"
        efreshdir src1 src2
        touch file0 src1/{file1,file2} src2/{file3,file4}

        etestmsg "Creating src.${ftype}"
        archive_create src.${ftype} file0 src1 src2
        assert_archive_contents src.${ftype} file0 src1 src1/{file1,file2} src2 src2/{file3,file4}

        rm src.${ftype}
    done
}

ETEST_archive_create_alternate_paths()
{
    local idx=0
    for idx in $(array_indexes ARCHIVE_TYPES); do
        local ftype="${ARCHIVE_TYPES[$idx]}"
        COLUMNS=${BANNER_WIDTH} ebanner "${ftype} ($((idx+1))/${#ARCHIVE_TYPES[@]})"

        etestmsg "Populating source directory"
        efreshdir src1 src2
        touch file0 src1/{file1,file2} src2/{file3,file4}

        etestmsg "Creating src.${ftype}"
        archive_create src.${ftype} file0:a_file0 src1:b_src1 src2:c_src2
        assert_archive_contents src.${ftype} a_file0 b_src1 b_src1/{file1,file2} c_src2 c_src2/{file3,file4}

        rm src.${ftype}
    done
}

ETEST_archive_create_alternate_paths_multiroot()
{
    local idx=0
    for idx in $(array_indexes ARCHIVE_TYPES); do
        local ftype="${ARCHIVE_TYPES[$idx]}"
        COLUMNS=${BANNER_WIDTH} ebanner "${ftype} ($((idx+1))/${#ARCHIVE_TYPES[@]})"

        etestmsg "Populating source directory"
        efreshdir src1 src2
        touch src1/{file1,file2} src2/{file3,file4}

        etestmsg "Creating src.${ftype}"
        archive_create src.${ftype} src1/. src2/.
        assert_archive_contents src.${ftype} file1 file2 file3 file4

        rm src.${ftype}
    done
}

ETEST_archive_create_exclude()
{
    local idx=0
    for idx in $(array_indexes ARCHIVE_TYPES); do
        local ftype="${ARCHIVE_TYPES[$idx]}"
        COLUMNS=${BANNER_WIDTH} ebanner "${ftype} ($((idx+1))/${#ARCHIVE_TYPES[@]})"

        etestmsg "Populating source directory"
        efreshdir src
        touch src/{file1,file2,XXX,YYY}

        etestmsg "Creating src.${ftype}"
        archive_create -x="src/XXX src/YYY" src.${ftype} src
        assert_archive_contents src.${ftype} src src/file1 src/file2
    done
}

ETEST_archive_create_exclude_illegal_prefix()
{
    local idx ftype src dest
    for idx in $(array_indexes ARCHIVE_TYPES); do
        ftype="${ARCHIVE_TYPES[$idx]}"
        COLUMNS=${BANNER_WIDTH} ebanner "${ftype} ($((idx+1))/${#ARCHIVE_TYPES[@]})"

        # NOTE: Need to use --tmpdir=/tmp because we want an absolute non-relative
        # path to be used (which is an illegal prefix to the archive formats).
        etestmsg "Populating source directory"
        src=$(mktemp --tmpdir=/tmp --directory archive-XXXXXX)
        touch ${src}/{file1,file2}

        # NOTE: Need to use --tmpdir=/tmp because we want an absolute non-relative
        # path to be used (which is an illegal prefix to the archive formats).
        etestmsg "Creating src/dest.${ftype}"
        dest=$(mktemp --tmpdir=/tmp archive-XXXXXX.${ftype})
        archive_create ${dest} ${src}
        assert_archive_contents ${dest} $(dirname ${src##/}) ${src##/} ${src##/}/file1 ${src##/}/file2
    done
}

ETEST_archive_create_exclude_glob()
{
    local idx ftype
    for idx in $(array_indexes ARCHIVE_TYPES); do
        ftype="${ARCHIVE_TYPES[$idx]}"
        COLUMNS=${BANNER_WIDTH} ebanner "${ftype} ($((idx+1))/${#ARCHIVE_TYPES[@]})"

        etestmsg "Populating source directory"
        efreshdir src src/tmp
        touch src/{file1,file2}
        touch src/tmp/{t1,t2,t3,t10,x1,x2,x3}

        etestmsg "Creating src.${ftype} (excluding tmp/*)"
        archive_create -x="src/tmp/*" src.${ftype} src
        assert_archive_contents src.${ftype} src src/file1 src/file2 src/tmp
        rm src.${ftype}

        etestmsg "Creating src.${ftype} (excluding tmp/t?)"
        archive_create -x="src/tmp/t?" src.${ftype} src
        assert_archive_contents src.${ftype} src src/file1 src/file2 src/tmp src/tmp/t10 src/tmp/x1 src/tmp/x2 src/tmp/x3

        etestmsg "Creating src.${ftype} (excluding tmp/t* tmp/x*)"
        archive_create -x="src/tmp/t* src/tmp/x*" src.${ftype} src
        assert_archive_contents src.${ftype} src src/file1 src/file2 src/tmp
    done
}

ETEST_archive_create_exclude_self()
{
    local idx ftype
    for idx in $(array_indexes ARCHIVE_TYPES); do
        ftype="${ARCHIVE_TYPES[$idx]}"
        COLUMNS=${BANNER_WIDTH} ebanner "${ftype} ($((idx+1))/${#ARCHIVE_TYPES[@]})"

        etestmsg "Populating source directory"
        efreshdir src
        touch src/{file1,file2}

        etestmsg "Creating src/dest.${ftype}"
        archive_create src/dest.${ftype} src
        assert_archive_contents src/dest.${ftype} src src/file1 src/file2
    done
}

# Ensure extra slashes in destination path doesn't cause archive_create to fail.
ETEST_archive_create_exclude_self_canonicalize()
{
    local idx ftype
    for idx in $(array_indexes ARCHIVE_TYPES); do
        ftype="${ARCHIVE_TYPES[$idx]}"
        COLUMNS=${BANNER_WIDTH} ebanner "${ftype} ($((idx+1))/${#ARCHIVE_TYPES[@]})"

        etestmsg "Populating source directory"
        efreshdir src
        touch src/{file1,file2}

        etestmsg "Creating src/dest.${ftype}"
        archive_create src///././///dest.${ftype} src
        assert_archive_contents src/dest.${ftype} src src/file1 src/file2
    done
}

# Realistic test of archiving pivot rooted rootfs
ETEST_archive_create_pivot_root()
{
    local idx ftype oldroot
    for idx in $(array_indexes ARCHIVE_TYPES); do
        ftype="${ARCHIVE_TYPES[$idx]}"
        COLUMNS=${BANNER_WIDTH} ebanner "${ftype} ($((idx+1))/${#ARCHIVE_TYPES[@]})"

        # NOTE: Need to use --tmpdir=/tmp because we want an absolute non-relative
        # path to be used (which is an illegal prefix to the archive formats).
        oldroot=$(mktemp --tmpdir=/tmp --directory oldroot-XXXXXX)

        etestmsg "Populating oldroot directory"
        mkdir -p ${oldroot}/{boot,var/log}
        touch ${oldroot}/boot/{initramfs-x86_64-3.12.13-gentoo,kernel-x86_64-3.12.13-gentoo,System.map-x86_64-3.12.13-gentoo}
        touch ${oldroot}/var/log/sf-master-{1..10}.info

        etestmsg "Creating ${oldroot}/var/log/sfbackup.${ftype}"
        archive_create ${oldroot}//var/log/sfbackup.${ftype} ${oldroot}
        assert_archive_contents ${oldroot}/var/log/sfbackup.${ftype} \
            tmp                                                \
            ${oldroot#/}                                       \
            ${oldroot#/}/boot                                  \
            ${oldroot#/}/boot/initramfs-x86_64-3.12.13-gentoo  \
            ${oldroot#/}/boot/kernel-x86_64-3.12.13-gentoo     \
            ${oldroot#/}/boot/System.map-x86_64-3.12.13-gentoo \
            ${oldroot#/}/var                                   \
            ${oldroot#/}/var/log                               \
            ${oldroot#/}/var/log/sf-master-10.info             \
            ${oldroot#/}/var/log/sf-master-1.info              \
            ${oldroot#/}/var/log/sf-master-2.info              \
            ${oldroot#/}/var/log/sf-master-3.info              \
            ${oldroot#/}/var/log/sf-master-4.info              \
            ${oldroot#/}/var/log/sf-master-5.info              \
            ${oldroot#/}/var/log/sf-master-6.info              \
            ${oldroot#/}/var/log/sf-master-7.info              \
            ${oldroot#/}/var/log/sf-master-8.info              \
            ${oldroot#/}/var/log/sf-master-9.info
    done
}

# Realistic test of archiving pivot rooted rootfs
ETEST_archive_create_pivot_root_cd_manual()
{
    local idx ftype oldroot
    for idx in $(array_indexes ARCHIVE_TYPES); do
        ftype="${ARCHIVE_TYPES[$idx]}"
        COLUMNS=${BANNER_WIDTH} ebanner "${ftype} ($((idx+1))/${#ARCHIVE_TYPES[@]})"

        oldroot=$(mktemp --tmpdir --directory oldroot-XXXXXX)
        etestmsg "Populating oldroot directory"
        mkdir -p ${oldroot}/{boot,var/log}
        touch ${oldroot}/boot/{initramfs-x86_64-3.12.13-gentoo,kernel-x86_64-3.12.13-gentoo,System.map-x86_64-3.12.13-gentoo}
        touch ${oldroot}/var/log/sf-master-{1..10}.info

        etestmsg "Creating ${oldroot}/var/log/sfbackup.${ftype}"
        (
            cd ${oldroot}
            archive_create ${oldroot}/var/log/sfbackup.${ftype} .
        )

        assert_archive_contents ${oldroot}/var/log/sfbackup.${ftype} \
            boot                                    \
            boot/initramfs-x86_64-3.12.13-gentoo    \
            boot/kernel-x86_64-3.12.13-gentoo       \
            boot/System.map-x86_64-3.12.13-gentoo   \
            var                                     \
            var/log                                 \
            var/log/sf-master-10.info               \
            var/log/sf-master-1.info                \
            var/log/sf-master-2.info                \
            var/log/sf-master-3.info                \
            var/log/sf-master-4.info                \
            var/log/sf-master-5.info                \
            var/log/sf-master-6.info                \
            var/log/sf-master-7.info                \
            var/log/sf-master-8.info                \
            var/log/sf-master-9.info
    done
}


# Realistic test of archiving pivot rooted rootfs
ETEST_archive_create_pivot_root_cd()
{
    local idx ftype oldroot
    for idx in $(array_indexes ARCHIVE_TYPES); do
        ftype="${ARCHIVE_TYPES[$idx]}"
        COLUMNS=${BANNER_WIDTH} ebanner "${ftype} ($((idx+1))/${#ARCHIVE_TYPES[@]})"

        oldroot=$(mktemp --tmpdir --directory oldroot-XXXXXX)
        etestmsg "Populating oldroot directory"
        mkdir -p ${oldroot}/{boot,var/log}
        touch ${oldroot}/boot/{initramfs-x86_64-3.12.13-gentoo,kernel-x86_64-3.12.13-gentoo,System.map-x86_64-3.12.13-gentoo}
        touch ${oldroot}/var/log/sf-master-{1..10}.info

        etestmsg "Creating ${oldroot}/var/log/sfbackup.${ftype}"
        archive_create ${oldroot}/var/log/sfbackup.${ftype} "${oldroot}/."

        assert_archive_contents ${oldroot}/var/log/sfbackup.${ftype} \
            boot                                    \
            boot/initramfs-x86_64-3.12.13-gentoo    \
            boot/kernel-x86_64-3.12.13-gentoo       \
            boot/System.map-x86_64-3.12.13-gentoo   \
            var                                     \
            var/log                                 \
            var/log/sf-master-10.info               \
            var/log/sf-master-1.info                \
            var/log/sf-master-2.info                \
            var/log/sf-master-3.info                \
            var/log/sf-master-4.info                \
            var/log/sf-master-5.info                \
            var/log/sf-master-6.info                \
            var/log/sf-master-7.info                \
            var/log/sf-master-8.info                \
            var/log/sf-master-9.info
    done
}

# Realistic test of archiving pivot rooted rootfs with multiple paths specified
ETEST_archive_create_pivot_root_multi()
{
    local idx ftype oldroot
    for idx in $(array_indexes ARCHIVE_TYPES); do
        ftype="${ARCHIVE_TYPES[$idx]}"
        COLUMNS=${BANNER_WIDTH} ebanner "${ftype} ($((idx+1))/${#ARCHIVE_TYPES[@]})"

        oldroot=$(mktemp --tmpdir --directory oldroot-XXXXXX)
        etestmsg "Populating oldroot directory"
        mkdir -p ${oldroot}/{boot,var/log}
        touch ${oldroot}/boot/{initramfs-x86_64-3.12.13-gentoo,kernel-x86_64-3.12.13-gentoo,System.map-x86_64-3.12.13-gentoo}
        touch ${oldroot}/var/log/sf-master-{1..10}.info

        KEEP_PATHS=( /boot /var )
        etestmsg "Creating ${oldroot}/var/log/sfbackup.${ftype}"
        archive_create -d="${oldroot}" ${oldroot}/var/log/sfbackup.${ftype} ${KEEP_PATHS[@]##/}

        assert_archive_contents ${oldroot}/var/log/sfbackup.${ftype} \
            boot                                    \
            boot/initramfs-x86_64-3.12.13-gentoo    \
            boot/kernel-x86_64-3.12.13-gentoo       \
            boot/System.map-x86_64-3.12.13-gentoo   \
            var                                     \
            var/log                                 \
            var/log/sf-master-10.info               \
            var/log/sf-master-1.info                \
            var/log/sf-master-2.info                \
            var/log/sf-master-3.info                \
            var/log/sf-master-4.info                \
            var/log/sf-master-5.info                \
            var/log/sf-master-6.info                \
            var/log/sf-master-7.info                \
            var/log/sf-master-8.info                \
            var/log/sf-master-9.info
    done
}

# Realistic test of archiving pivot rooted rootfs with multiple paths specified
ETEST_archive_create_pivot_root_multi_cd_manual()
{
    local idx ftype oldroot
    for idx in $(array_indexes ARCHIVE_TYPES); do
        ftype="${ARCHIVE_TYPES[$idx]}"
        COLUMNS=${BANNER_WIDTH} ebanner "${ftype} ($((idx+1))/${#ARCHIVE_TYPES[@]})"

        oldroot=$(mktemp --tmpdir --directory oldroot-XXXXXX)
        etestmsg "Populating oldroot directory"
        mkdir -p ${oldroot}/{boot,var/log}
        touch ${oldroot}/boot/{initramfs-x86_64-3.12.13-gentoo,kernel-x86_64-3.12.13-gentoo,System.map-x86_64-3.12.13-gentoo}
        touch ${oldroot}/var/log/sf-master-{1..10}.info

        KEEP_PATHS=( /boot /var )
        etestmsg "Creating ${oldroot}/var/log/sfbackup.${ftype}"
        (
            cd ${oldroot}
            archive_create ${oldroot}/var/log/sfbackup.${ftype} ${KEEP_PATHS[@]##/}
        )

        assert_archive_contents ${oldroot}/var/log/sfbackup.${ftype} \
            boot                                    \
            boot/initramfs-x86_64-3.12.13-gentoo    \
            boot/kernel-x86_64-3.12.13-gentoo       \
            boot/System.map-x86_64-3.12.13-gentoo   \
            var                                     \
            var/log                                 \
            var/log/sf-master-10.info               \
            var/log/sf-master-1.info                \
            var/log/sf-master-2.info                \
            var/log/sf-master-3.info                \
            var/log/sf-master-4.info                \
            var/log/sf-master-5.info                \
            var/log/sf-master-6.info                \
            var/log/sf-master-7.info                \
            var/log/sf-master-8.info                \
            var/log/sf-master-9.info
    done
}

ETEST_archive_create_exclude_self_multi()
{
    local idx ftype
    for idx in $(array_indexes ARCHIVE_TYPES); do
        ftype="${ARCHIVE_TYPES[$idx]}"
        COLUMNS=${BANNER_WIDTH} ebanner "${ftype} ($((idx+1))/${#ARCHIVE_TYPES[@]})"

        etestmsg "Populating source directory"
        efreshdir src1 src2
        touch src1/{file1,file2} src2/{file3,file4}

        etestmsg "Creating src1/dest.${ftype}"
        archive_create src1/dest.${ftype} src1 src2
        assert_archive_contents src1/dest.${ftype} src1 src1/{file1,file2} src2 src2/{file3,file4}
    done
}

ETEST_archive_create_exclude_files()
{
    local idx ftype
    for idx in $(array_indexes ARCHIVE_TYPES); do
        ftype="${ARCHIVE_TYPES[$idx]}"
        COLUMNS=${BANNER_WIDTH} ebanner "${ftype} ($((idx+1))/${#ARCHIVE_TYPES[@]})"

        etestmsg "Creating files"
        touch {file1,file2,file3,file4,XXX,YYY}

        etestmsg "Creating dest.${ftype}"
        archive_create -x="XXX YYY" src.${ftype} file1 file2 file3 file4 XXX YYY
        assert_archive_contents src.${ftype} file1 file2 file3 file4
        rm src.${ftype}
   done
}

ETEST_archive_create_custom_suffix()
{
    etestmsg "Populating source directory"
    efreshdir src
    touch src/{file1,file2}

    etestmsg "Creating dest.upr"
    archive_create --type=tar dest.upr src
    archive_list --type=tar dest.upr
    assert_archive_contents --type=tar dest.upr src src/file1 src/file2
}

ETEST_archive_create_mount()
{
    local idx ftype atype
    for idx in $(array_indexes ARCHIVE_TYPES); do
        ftype="${ARCHIVE_TYPES[$idx]}"
        COLUMNS=${BANNER_WIDTH} ebanner "${ftype} ($((idx+1))/${#ARCHIVE_TYPES[@]})"

        etestmsg "Creating files"
        touch {file1,file2,file3,file4,XXX,YYY}

        etestmsg "Creating dest.${ftype}"
        archive_create -x="XXX YYY" src.${ftype} file1 file2 file3 file4 XXX YYY

        # Mount it and verify mount type
        archive_mount src.${ftype} dest
        atype=$(archive_type .${ftype})
        if [[ ${atype} =~ tar|cpio ]]; then
            assert_false emount_type dest
        elif [[ ${atype} == iso ]]; then
            assert_eq "iso9660" "$(emount_type dest)"
        else
            assert_eq "${atype}" "$(emount_type dest)"
        fi

        eunmount --all --recursive --delete dest src.${ftype}
   done
}

ETEST_archive_extract()
{
    local idx ftype
    for idx in $(array_indexes ARCHIVE_TYPES); do
        ftype="${ARCHIVE_TYPES[$idx]}"
        COLUMNS=${BANNER_WIDTH} ebanner "${ftype} ($((idx+1))/${#ARCHIVE_TYPES[@]})"

        etestmsg "Populating source directory"
        efreshdir src dest
        touch src/{file1,file2}

        etestmsg "Creating src.${ftype}"
        archive_create src.${ftype} src

        etestmsg "Extracting src.${ftype} to dest"
        archive_extract src.${ftype} dest

        etestmsg "Validating src and dest"
        diff --unified --recursive src dest/src
    done
}

ETEST_archive_extract_type()
{
    etestmsg "Populating source directory"
    efreshdir src dest
    touch src/{file1,file2}

    etestmsg "Creating src.img"
    archive_create -t=clz src.img src

    etestmsg "Extracting src.img to dest (clz)"
    archive_extract -t=clz src.img dest

    etestmsg "Validating src and dest"
    diff --unified --recursive src dest/src
}

ETEST_archive_extract_files_same()
{
    local idx ftype
    for idx in $(array_indexes ARCHIVE_TYPES); do
        ftype="${ARCHIVE_TYPES[$idx]}"
        COLUMNS=${BANNER_WIDTH} ebanner "${ftype} ($((idx+1))/${#ARCHIVE_TYPES[@]})"

        etestmsg "Creating files"
        touch {file1,file2,file3,file4}

        etestmsg "Creating src.${ftype}"
        archive_create src.${ftype} file1 file2 file3 file4
        assert_archive_contents src.${ftype} file1 file2 file3 file4

        etestmsg "Extracting src.${ftype} over original source files"
        archive_extract src.${ftype} . file1 file2 file3 file4

        rm --force src.${ftype}
    done
}


ETEST_archive_extract_pivot_root_multi_deep()
{
    local idx ftype oldroot expect
    for idx in $(array_indexes ARCHIVE_TYPES); do
        ftype="${ARCHIVE_TYPES[$idx]}"
        COLUMNS=${BANNER_WIDTH} ebanner "${ftype} ($((idx+1))/${#ARCHIVE_TYPES[@]})"

        oldroot=$(mktemp --tmpdir --directory oldroot-XXXXXX)
        etestmsg "Populating oldroot directory"
        mkdir -p ${oldroot}/{boot,var/log}
        touch ${oldroot}/boot/{initramfs-x86_64-3.12.13-gentoo,kernel-x86_64-3.12.13-gentoo,System.map-x86_64-3.12.13-gentoo}
        touch ${oldroot}/var/log/sf-master-{1..10}.info

        KEEP_PATHS=( /boot/{initramfs-x86_64-3.12.13-gentoo,kernel-x86_64-3.12.13-gentoo,System.map-x86_64-3.12.13-gentoo}
                     /var/log/sf-master-{1..10}.info
                    )

        expect=(                                    \
            boot                                    \
            boot/initramfs-x86_64-3.12.13-gentoo    \
            boot/kernel-x86_64-3.12.13-gentoo       \
            boot/System.map-x86_64-3.12.13-gentoo   \
            var                                     \
            var/log                                 \
            var/log/sf-master-10.info               \
            var/log/sf-master-1.info                \
            var/log/sf-master-2.info                \
            var/log/sf-master-3.info                \
            var/log/sf-master-4.info                \
            var/log/sf-master-5.info                \
            var/log/sf-master-6.info                \
            var/log/sf-master-7.info                \
            var/log/sf-master-8.info                \
            var/log/sf-master-9.info                \
        )

        etestmsg "Creating ${oldroot}/var/log/sfbackup.${ftype}"
        (
            cd ${oldroot}
            find . -printf '%P\n'
            archive_create ${oldroot}/var/log/sfbackup.${ftype} ${KEEP_PATHS[@]##/}
        )
        assert_archive_contents ${oldroot}/var/log/sfbackup.${ftype} ${expect[@]}

        etestmsg "Extracting"
        archive_extract ${oldroot}/var/log/sfbackup.${ftype} restore ${KEEP_PATHS[@]##/}
        assert_directory_contents restore ${expect[@]}
    done
}

ETEST_archive_extract_specific_files()
{
    local idx ftype
    for idx in $(array_indexes ARCHIVE_TYPES); do
        ftype="${ARCHIVE_TYPES[$idx]}"
        COLUMNS=${BANNER_WIDTH} ebanner "${ftype} ($((idx+1))/${#ARCHIVE_TYPES[@]})"

        etestmsg "Populating source directory"
        efreshdir src dest
        touch src/{file1,file2,XXX,YYY}

        etestmsg "Creating src.${ftype}"
        archive_create src.${ftype} src

        etestmsg "Extracting src.${ftype}/{file1,file2} to dest"
        archive_extract src.${ftype} dest src/{file1,file2}
        assert_directory_contents dest src src/file1 src/file2
   done
}

ETEST_archive_extract_missing_required_files()
{
    local idx ftype
    for idx in $(array_indexes ARCHIVE_TYPES); do
        ftype="${ARCHIVE_TYPES[$idx]}"
        COLUMNS=${BANNER_WIDTH} ebanner "${ftype} ($((idx+1))/${#ARCHIVE_TYPES[@]})"

        etestmsg "Populating source directory"
        efreshdir src dest
        touch src/{file1,file2,XXX,YYY}

        etestmsg "Creating src.${ftype}"
        archive_create src.${ftype} src

   done
}

ETEST_archive_extract_ignore_missing()
{
    local idx ftype
    for idx in $(array_indexes ARCHIVE_TYPES); do
        ftype="${ARCHIVE_TYPES[$idx]}"
        COLUMNS=${BANNER_WIDTH} ebanner "${ftype} ($((idx+1))/${#ARCHIVE_TYPES[@]})"

        etestmsg "Populating source directory"
        efreshdir src dest
        touch src/{file1,file2,XXX,YYY}

        etestmsg "Creating src.${ftype}"
        archive_create src.${ftype} src

        etestmsg "Extracting src.${ftype}/{file1,file2} to dest (should fail)"
        assert_false archive_extract src.${ftype} dest src/NOT1 src/file1 src/file2 src/NOT2
        #BUG: assert directory_empty dest
        rm -rf dest

        etestmsg "Extracting src.${ftype}/{file1,file2} to dest (should NOT fail -- ignoring missing files)"
        archive_extract -i src.${ftype} dest src/NOT1 src/file1 src/file2 src/NOT2
        assert_directory_contents dest src src/file1 src/file2
        rm -rf dest

        etestmsg "Extracting src.${ftype} with nothing to do"
        archive_extract -i src.${ftype} dest NOT1 NOT2
        assert directory_empty dest
        rm -rf dest
    done
}

ETEST_archive_extract_glob()
{
    local idx ftype
    for idx in $(array_indexes ARCHIVE_TYPES); do
        ftype="${ARCHIVE_TYPES[$idx]}"
        COLUMNS=${BANNER_WIDTH} ebanner "${ftype} ($((idx+1))/${#ARCHIVE_TYPES[@]})"

        etestmsg "Populating source directory"
        efreshdir src src/tmp dest
        touch src/{file1,file2,XXX,YYY,tmp/1,tmp/2}

        etestmsg "Creating src.${ftype}"
        archive_create src.${ftype} src
        archive_list src.${ftype}

        etestmsg "Extracting src.${ftype}/{file*,tmp/*} to dest"
        archive_extract src.${ftype} dest "src/file*" "src/tmp/*"
        assert_directory_contents dest src src/{file1,file2,tmp,tmp/1,tmp/2}
    done
}

ETEST_archive_extract_content()
{
    local idx ftype
    for idx in $(array_indexes ARCHIVE_TYPES); do
        ftype="${ARCHIVE_TYPES[$idx]}"
        COLUMNS=${BANNER_WIDTH} ebanner "${ftype} ($((idx+1))/${#ARCHIVE_TYPES[@]})"

        etestmsg "Populating source directory"
        efreshdir src dest
        touch src/{file1,file2}
        echo "data1" >src/file1
        echo "data2" >src/file2

        etestmsg "Creating src.${ftype}"
        archive_create src.${ftype} src

        etestmsg "Extracting src.${ftype} to dest"
        archive_extract src.${ftype} dest

        etestmsg "Validating src and dest"
        diff --unified --recursive src dest/src
    done
}

ETEST_archive_extract_strip_invalid()
{
    $(tryrc archive_extract --strip-components -1 src dest)
    assert_eq 1 "${rc}"

    $(tryrc archive_extract --strip-components  a  src dest)
    assert_eq 1 "${rc}"

    $(tryrc archive_extract --strip-components  "" src dest)
    assert_eq 1 "${rc}"
}

ETEST_archive_extract_strip1()
{
    local idx ftype
    for idx in $(array_indexes ARCHIVE_TYPES); do
        ftype="${ARCHIVE_TYPES[$idx]}"
        COLUMNS=${BANNER_WIDTH} ebanner "${ftype} ($((idx+1))/${#ARCHIVE_TYPES[@]})"

        etestmsg "Populating source directory"
        efreshdir src dest
        mkdir -p src/s1
        mkdir -p src/s2
        mkdir -p src/s3

        etestmsg "Creating src.${ftype}"
        archive_create src.${ftype} src

        etestmsg "Extracting src.${ftype} to dest"
        archive_extract --strip-components 1 src.${ftype} dest

        etestmsg "Validating src and dest"
        assert_directory_contents dest s1 s2 s3
    done
}

ETEST_archive_extract_strip1_deep()
{
    local idx ftype
    for idx in $(array_indexes ARCHIVE_TYPES); do
        ftype="${ARCHIVE_TYPES[$idx]}"
        COLUMNS=${BANNER_WIDTH} ebanner "${ftype} ($((idx+1))/${#ARCHIVE_TYPES[@]})"

        etestmsg "Populating source directory"
        efreshdir src dest
        mkdir -p src/s1/s1a src/s1/s1b; touch src/s1/s1f src/s1/s1a/s1af src/s1/s1a/s1bf1 src/s1/s1a/s1bf2
        mkdir -p src/s2/s2a src/s2/s2b; touch src/s2/s2f src/s2/s2a/s2af src/s2/s2a/s2bf1 src/s2/s2a/s2bf2
        mkdir -p src/s3/s3a src/s3/s3b; touch src/s3/s3f src/s3/s3a/s3af src/s3/s3a/s3bf1 src/s3/s3a/s3bf2

        etestmsg "Creating src.${ftype}"
        archive_create src.${ftype} src

        etestmsg "Extracting src.${ftype} to dest"
        archive_extract --strip-components 1 src.${ftype} dest

        etestmsg "Validating src and dest"
        assert_directory_contents dest                                              \
            s1 s1/s1a s1/s1b s1/s1f s1/s1a/s1af s1/s1a/s1bf1 s1/s1a/s1bf2           \
            s2 s2/s2a s2/s2b s2/s2f s2/s2a s2/s2a/s2af s2/s2a/s2bf1 s2/s2a/s2bf2    \
            s3 s3/s3a s3/s3b s3/s3f s3/s3a s3/s3a/s3af s3/s3a/s3bf1 s3/s3a/s3bf2
    done
}

ETEST_archive_extract_strip2()
{
    local idx ftype
    for idx in $(array_indexes ARCHIVE_TYPES); do
        ftype="${ARCHIVE_TYPES[$idx]}"
        COLUMNS=${BANNER_WIDTH} ebanner "${ftype} ($((idx+1))/${#ARCHIVE_TYPES[@]})"

        etestmsg "Populating source directory"
        efreshdir src dest
        mkdir -p src/s1/s1a
        mkdir -p src/s2/s2a
        mkdir -p src/s3/s3a

        etestmsg "Creating src.${ftype}"
        archive_create src.${ftype} src

        etestmsg "Extracting src.${ftype} to dest"
        archive_extract --strip-components 2 src.${ftype} dest

        etestmsg "Validating src and dest"
        assert_directory_contents dest \
            s1a \
            s2a \
            s3a
    done
}

ETEST_archive_extract_strip2_deep()
{
    local idx ftype
    for idx in $(array_indexes ARCHIVE_TYPES); do
        ftype="${ARCHIVE_TYPES[$idx]}"
        COLUMNS=${BANNER_WIDTH} ebanner "${ftype} ($((idx+1))/${#ARCHIVE_TYPES[@]})"

        etestmsg "Populating source directory"
        efreshdir src dest
        mkdir -p src/s1/s1a src/s1/s1b; touch src/s1/s1f src/s1/s1a/s1af src/s1/s1a/s1bf1 src/s1/s1a/s1bf2
        mkdir -p src/s2/s2a src/s2/s2b; touch src/s2/s2f src/s2/s2a/s2af src/s2/s2a/s2bf1 src/s2/s2a/s2bf2
        mkdir -p src/s3/s3a src/s3/s3b; touch src/s3/s3f src/s3/s3a/s3af src/s3/s3a/s3bf1 src/s3/s3a/s3bf2

        etestmsg "Creating src.${ftype}"
        archive_create src.${ftype} src

        etestmsg "Extracting src.${ftype} to dest"
        archive_extract --strip-components 2 src.${ftype} dest
        find dest

        etestmsg "Validating src and dest"
        assert_directory_contents dest                  \
            s1a s1b s1f s1a/s1af s1a/s1bf1 s1a/s1bf2    \
            s2a s2b s2f s2a/s2af s2a/s2bf1 s2a/s2bf2    \
            s3a s3b s3f s3a/s3af s3a/s3bf1 s3a/s3bf2
    done
}

ETEST_archive_extract_strip_more_than_exists()
{
    local idx ftype
    for idx in $(array_indexes ARCHIVE_TYPES); do
        ftype="${ARCHIVE_TYPES[$idx]}"
        COLUMNS=${BANNER_WIDTH} ebanner "${ftype} ($((idx+1))/${#ARCHIVE_TYPES[@]})"

        etestmsg "Populating source directory"
        efreshdir src dest
        mkdir -p src/s1/s1a src/s1/s1b; touch src/s1/s1f src/s1/s1a/s1af src/s1/s1a/s1bf1 src/s1/s1a/s1bf2
        mkdir -p src/s2/s2a src/s2/s2b; touch src/s2/s2f src/s2/s2a/s2af src/s2/s2a/s2bf1 src/s2/s2a/s2bf2
        mkdir -p src/s3/s3a src/s3/s3b; touch src/s3/s3f src/s3/s3a/s3af src/s3/s3a/s3bf1 src/s3/s3a/s3bf2

        etestmsg "Creating src.${ftype}"
        archive_create src.${ftype} src

        etestmsg "Extracting src.${ftype} to dest"
        archive_extract --strip-components 10 src.${ftype} dest
        find dest

        etestmsg "Validating src and dest"
        assert_directory_contents dest
    done
}


ETEST_archive_extract_strip_collisions()
{
    local idx ftype
    for idx in $(array_indexes ARCHIVE_TYPES); do
        ftype="${ARCHIVE_TYPES[$idx]}"
        COLUMNS=${BANNER_WIDTH} ebanner "${ftype} ($((idx+1))/${#ARCHIVE_TYPES[@]})"

        etestmsg "Populating source directory"
        efreshdir src dest
        mkdir -p src/{s1,s2,s3}
        touch    src/{s1,s2,s3}/f
        echo "s1" > src/s1/f
        echo "s2" > src/s2/f
        echo "s3" > src/s3/f

        etestmsg "Creating src.${ftype}"
        archive_create src.${ftype} src

        etestmsg "Extracting src.${ftype} to dest"
        archive_extract --strip-components 2 src.${ftype} dest

        etestmsg "Validating src and dest"
        assert_directory_contents dest f f.~1~ f.~2~

        # We can't guarantee the order the files are copied in b/c that's dependant on the inode structure and filesystem.
        # So instead we just assert that we see all three files with the three different contents we expect to see.
        assert_eq $'s1\ns2\ns3' "$(cat dest/f dest/f.~1~ dest/f.~2~ | sort)"
    done
}

ETEST_archive_append()
{
    local idx type
    for idx in $(array_indexes ARCHIVE_TYPES); do
        ftype="${ARCHIVE_TYPES[$idx]}"
        COLUMNS=${BANNER_WIDTH} ebanner "${ftype} ($((idx+1))/${#ARCHIVE_TYPES[@]})"

        etestmsg "Populating source directory"
        efreshdir src dest
        touch src/{file1,file2}

        etestmsg "Creating src.${ftype}"
        archive_create src.${ftype} src
        assert_exists src.${ftype}

        etestmsg "Appending new files"
        touch file3 file4
        archive_append src.${ftype} file3:src/file3 file4:src/file4

        etestmsg "Extracting"
        archive_extract src.${ftype} dest
        assert_directory_contents dest src src/{file1,file2,file3,file4}
    done
}

ETEST_archive_append_delete()
{
    local idx ftype
    for idx in $(array_indexes ARCHIVE_TYPES); do
        ftype="${ARCHIVE_TYPES[$idx]}"
        COLUMNS=${BANNER_WIDTH} ebanner "${ftype} ($((idx+1))/${#ARCHIVE_TYPES[@]})"

        etestmsg "Populating source directory"
        efreshdir src dest
        touch src/{file1,file2}

        etestmsg "Creating src.${ftype}"
        archive_create --delete src.${ftype} src
        assert_exists src.${ftype}

        etestmsg "Appending new files"
        touch file3 file4
        archive_append --delete src.${ftype} file3:src/file3 file4:src/file4

        etestmsg "Extracting"
        archive_extract src.${ftype} dest
        assert_directory_contents dest src src/{file1,file2,file3,file4}

        # Ensure source files were deleted
        assert_not_exists src src/file1 src/file2 file3 file4
    done
}

ETEST_archive_append_overwrite()
{
    local idx ftype
    for idx in $(array_indexes ARCHIVE_TYPES); do
        ftype="${ARCHIVE_TYPES[$idx]}"
        COLUMNS=${BANNER_WIDTH} ebanner "${ftype} ($((idx+1))/${#ARCHIVE_TYPES[@]})"

        etestmsg "Populating source directory"
        efreshdir src dest
        touch src/{file1,file2}
        echo "data1" >src/file1
        echo "data2" >src/file2

        etestmsg "Creating src.${ftype}"
        archive_create src.${ftype} src
        assert_exists src.${ftype}

        etestmsg "Appending file with new content"
        echo "XXXX1" >file3
        echo "XXXX2" >file4
        archive_append src.${ftype} file3:src/file1 file4:src/file2

        etestmsg "Extracting"
        archive_extract src.${ftype} dest
        assert_directory_contents dest src src/{file1,file2}

        etestmsg "Validating updated contents"
        assert_eq "XXXX1" "$(cat dest/src/file1)"
        assert_eq "XXXX2" "$(cat dest/src/file2)"
    done
}

ETEST_archive_append_no_shadow_mount_files()
{
    local idx ftype
    for idx in $(array_indexes ARCHIVE_TYPES); do
        ftype="${ARCHIVE_TYPES[$idx]}"
        COLUMNS=${BANNER_WIDTH} ebanner "${ftype} ($((idx+1))/${#ARCHIVE_TYPES[@]})"

        etestmsg "Populating source directory"
        efreshdir dest
        touch file1 file2

        etestmsg "Creating src.${ftype}"
        archive_create src.${ftype} file1 file2
        assert_exists src.${ftype}

        etestmsg "Appending new files"
        efreshdir new
        touch new/file3 new/file4
        archive_append src.${ftype} new/.

        etestmsg "Extracting"
        archive_extract src.${ftype} dest
        assert_directory_contents dest file1 file2 file3 file4
    done
}

ETEST_archive_append_no_shadow_mount_directory()
{
    local idx ftype
    for idx in $(array_indexes ARCHIVE_TYPES); do
        ftype="${ARCHIVE_TYPES[$idx]}"
        COLUMNS=${BANNER_WIDTH} ebanner "${ftype} ($((idx+1))/${#ARCHIVE_TYPES[@]})"

        etestmsg "Populating source directory"
        efreshdir src dest
        touch src/{file1,file2}

        etestmsg "Creating src.${ftype}"
        archive_create src.${ftype} src
        assert_exists src.${ftype}

        etestmsg "Appending new files"
        efreshdir src
        touch src/{file3,file4}
        archive_append src.${ftype} src

        etestmsg "Extracting"
        archive_extract src.${ftype} dest
        assert_directory_contents dest src src/{file1,file2,file3,file4}
    done
}

ETEST_archive_append_nonexisting()
{
    local idx ftype
    for idx in $(array_indexes ARCHIVE_TYPES); do
        ftype="${ARCHIVE_TYPES[$idx]}"
        COLUMNS=${BANNER_WIDTH} ebanner "${ftype} ($((idx+1))/${#ARCHIVE_TYPES[@]})"

        etestmsg "Populating source directory"
        efreshdir src dest
        touch src/{file1,file2}

        etestmsg "Creating src.${ftype}"
        archive_append src.${ftype} src
        assert_exists src.${ftype}

        etestmsg "Extracting"
        archive_extract src.${ftype} dest
        assert_directory_contents dest src src/{file1,file2}
    done
}

ETEST_archive_xnice()
{
    local idx ftype
    for idx in $(array_indexes ARCHIVE_TYPES); do
        ftype="${ARCHIVE_TYPES[$idx]}"
        COLUMNS=${BANNER_WIDTH} ebanner "${ftype} ($((idx+1))/${#ARCHIVE_TYPES[@]})"

        etestmsg "Populating source directory"
        efreshdir src dest
        touch src/{file1,file2}

        etestmsg "Creating src.${ftype}"
        archive_create --nice src.${ftype} src

        etestmsg "Extracting src.${ftype} to dest"
        archive_extract --nice src.${ftype} dest

        etestmsg "Validating src and dest"
        diff --unified --recursive src dest/src
    done
}

ETEST_archive_xconvert()
{
    local idx ftype
    for idx in $(array_indexes ARCHIVE_TYPES); do
        ftype="${ARCHIVE_TYPES[$idx]}"
        COLUMNS=${BANNER_WIDTH} ebanner "${ftype} ($((idx+1))/${#ARCHIVE_TYPES[@]})"

        etestmsg "Populating source directory"
        efreshdir src
        touch src/{file1,file2}

        etestmsg "Creating src.${ftype}"
        archive_create src.${ftype} src

        local other src_contents cpy_contents src_contents_join cpy_contents_join
        for other in ${ARCHIVE_TYPES[@]}; do

            etestmsg "Converting src.${ftype} to cpy.${other}"
            archive_convert src.${ftype} cpy.${other}

            etestmsg "Validating contents of cpy.${other}"
            src_contents=( $(archive_list src.${ftype}) )
            cpy_contents=( $(archive_list cpy.${other}) )
            etestmsg "$(lval src_contents cpy_contents)"
            assert_eq $(array_size src_contents) $(array_size cpy_contents)

            # Also compare and diff as arrays
            src_contents_join=$(array_join src_contents :)
            cpy_contents_join=$(array_join cpy_contents :)
            assert_eq "${src_contents_join}" "${cpy_contents_join}"
        done

    done
}

ETEST_archive_xdiff()
{
    local idx ftype
    for idx in $(array_indexes ARCHIVE_TYPES); do
        ftype="${ARCHIVE_TYPES[$idx]}"
        COLUMNS=${BANNER_WIDTH} ebanner "${ftype} ($((idx+1))/${#ARCHIVE_TYPES[@]})"

        etestmsg "Populating source directory"
        efreshdir src
        touch src/{file1,file2}

        etestmsg "Creating src.${ftype}"
        archive_create src.${ftype} src

        # Iterate over all types and create copy -- diff should match
        for other in ${ARCHIVE_TYPES[@]}; do

            etestmsg "Creating cpy.${other}"
            archive_create cpy.${other} src

            etestmsg "Diffing against cpy.${other}"
            archive_diff src.${ftype} cpy.${other}
        done

        # Iterate over all types and create a different copy with extra file
        # diff should not match.
        for other in ${ARCHIVE_TYPES[@]}; do

            etestmsg "Creating diff.${other}"
            efreshdir diff
            cp src/* diff
            touch diff/EXTRA_FILE
            archive_create diff.${other} diff

            etestmsg "Diffing against diff.${other} (should fail)"
            $(tryrc archive_diff src.${ftype} diff.${other})
            assert_ne 0 ${rc}
        done
    done
}

# Verify that a bootable ISO can be booted into properly using VirtualBox. If VirtualBox is not installed
# then this test will simply log a warning and return success as we don't want to require VirtualBox to be
# installed on all our test slaves.
ETEST_archive_bootable_iso_virtualbox()
{
    if ! command_exists VBoxManage; then
        ewarn "VirtualBox is not installed -- skipping"
        return 0
    fi

    # Unique name for the VM
    VM="${FUNCNAME}_$$"

    # Generate unique socket ID to make VirtualBox use a separate daemon.
    # Set directory for VirtualBox config and log files (like VirtualBox.xml and VBoxSVC.log)
    # And also set directory for VM files (.vbox, .vmdk, per-VM logs)
    VBOX_IPC_SOCKETID="${VM}"
    VBOX_USER_HOME="$(readlink -m ./VirtualBox/${VM})"
    export VBOX_IPC_SOCKETID VBOX_USER_HOME
    VBoxManage setproperty machinefolder "${VBOX_USER_HOME}"

    etestmsg "VirtualBox configuration"
    einfo "$(lval VM)"
    einfo "$(lval VBOX_IPC_SOCKETID)"
    einfo "$(lval VBOX_USER_HOME)"

    # The syslinux files on various distros are in vastly different places. So try to find them in all known locations
    # but ignore errors as find returns non-zero if any of the requested paths don't exist.
    etestmsg "Creating isolinux tree"
    mkdir -p work/isolinux
    find /usr/share/syslinux /usr/lib/syslinux/{mbr,modules/bios} /usr/lib/ISOLINUX -type f -exec cp {} work/isolinux \; 2>/dev/null || true

    # Make sure required files were found
    ls -C work/isolinux
    assert_exists work/isolinux/{isolinux.bin,mbr.bin,poweroff.c32}

    {
        echo "DEFAULT poweroff"
        echo "PROMPT 0"
        echo ""
        echo "LABEL poweroff"
        echo "    COM32 poweroff.c32"
        echo ""

    } > work/isolinux/isolinux.cfg

    etestmsg "Creating archive"
    archive_create --bootable "work.iso" "work/."

    etestmsg "Converting ISO into VDI"
    VBoxManage convertfromraw "work.iso" "work.vdi"

    # Now create a VirtualBox VM and have it boot using the bootable ISO. The VM should immediately shutdown since we've
    # setup a dummy extlinux menu which simply powers off the VM. If the VM does not power off immediately, then the call
    # to VBoxHeadless will actually hang. To guard against that wrap it in an etimeout. If it doesn't complete within a
    # few seconds then something failed. But to avoid a flaky test set this to 60s to give it plenty of time.
    etestmsg "Create VM"
    VBoxManage createvm --name "${VM}" --ostype "Other" --register
    VBoxManage storagectl "${VM}" --name "SATA Controller" --add sata --controller IntelAHCI
    VBoxManage storageattach "${VM}" --storagectl "SATA Controller" --port 0 --device 0 --type hdd --medium "work.vdi"
    etimeout --timeout=60s VBoxHeadless --startvm "${VM}"

    # Wait for the VirtualBox processes spawned for this test to shutdown too. We know there are two processes launched
    # 'VVboxSVC' and 'VBoxXPCOMIPCD'. But we don't want to wait for process we didn't spawn. So we look at any matching
    # process and check if it has the env variables we set above. If so, wait for it to stop.
    etestmsg "Looking for VirtualBox processes to wait on"
    local pid="" pids=() socket=""
    for pid in $(pgrep "VBoxSVC|VBoxXPCOMIPCD"); do
        socket=$(grep -z "VBOX_IPC_SOCKETID=.*" "/proc/${pid}/environ" | sed 's|VBOX_IPC_SOCKETID=||' || true)
        edebug "$(lval socket VBOX_IPC_SOCKETID)"
        if [[ "${socket}" == "${VBOX_IPC_SOCKETID}" ]]; then
            einfos "${pid}"
            pids+=( ${pid} )
        fi
    done

    eprogress "Waiting for $(lval pids) to exit"
    eretry --max-timeout=60s process_not_running "${pids[@]}"
    eprogress_kill
}
