#!/usr/bin/env bash
#
# Copyright 2011-2018, Marshall McMullen <marshall.mcmullen@gmail.com>
# Copyright 2011-2018, SolidFire, Inc. All rights reserved.
#
# This program is free software: you can redistribute it and/or modify it under the terms of the Apache License
# as published by the Apache Software Foundation, either version 2 of the License, or (at your option) any later
# version.

# Mock docker function to intercept "docker push" commands for better testability.
docker_tags_pushed=()
docker()
{
    if [[ "${1}" == "push" ]]; then
        etestmsg "Simulating docker push tags=${*}"
        shift
        docker_tags_pushed+=( "${@}" )
        return 0
    elif [[ "${1}" == "login" ]]; then
        etestmsg "Simulated docker login with args=${*}"
        return 0
    fi

    command docker "${@}"
}

setup()
{
    docker_tags_pushed=()
    EDEBUG+=" docker"
}

ETEST_docker_build()
{
    etestmsg "Creating Dockerfile"
	cat <<-END >Dockerfile
	FROM alpine:edge
	ENV CREATOR etest-$$
	END
    cat Dockerfile

    etestmsg "Building docker image"
    docker_build --name "elibs/ebash"

    etestmsg "Validating docker_build artifacts"
    find ".work/docker/ebash" -ls
    assert_exists \
        ".work/docker/ebash/build.log"  \
        ".work/docker/ebash/dockerfile" \
        ".work/docker/ebash/history"    \
        ".work/docker/ebash/image"      \
        ".work/docker/ebash/inspect"    \
        ".work/docker/ebash/options"    \
        ".work/docker/ebash/sha"        \
        ".work/docker/ebash/sha.func"   \
        ".work/docker/ebash/sha.short"  \
        ".work/docker/ebash/sha.detail" \

    etestmsg "Validating Docker Image was built"
    image="$(cat .work/docker/ebash/image)"
    assert_eq "elibs/ebash:$(cat .work/docker/ebash/sha.short)" "${image}"
    etestmsg "$(lval image)"
    trap_add "docker rmi ${image}"

    assert_docker_image_exists "${image}"
}

# Verify if we use --pretend on a non-existant image that it returns 1 and doesn't do anything.
ETEST_docker_build_and_pretend()
{
    etestmsg "Creating Dockerfile"
	cat <<-END >Dockerfile
	FROM alpine:edge
	ENV CREATOR etest-$$
	END
    cat Dockerfile

    etestmsg "Building docker image (PRETEND)"
    $(tryrc docker_build     \
        --name "elibs/ebash" \
        --pretend            \
    )
    assert_eq 1 "${rc}"

    etestmsg "Validating docker_build artifacts"
    assert_exists \
        ".work/docker/ebash/dockerfile" \
        ".work/docker/ebash/image"      \
        ".work/docker/ebash/sha"        \
        ".work/docker/ebash/sha.func"   \
        ".work/docker/ebash/sha.short"  \
        ".work/docker/ebash/sha.detail" \

    etestmsg "Validating docker_build artifacts that should NOT have been created"
    assert_not_exists \
        ".work/docker/ebash/build.log"  \
        ".work/docker/ebash/history" \
        ".work/docker/ebash/inspect" \

    etestmsg "Validating Docker Image was NOT built"
    image="$(cat .work/docker/ebash/image)"
    etestmsg "$(lval image)"
    assert_docker_image_not_exists "${image}"
}

# Verify that provided build args are no longer interpolated (change from original behavior).
ETEST_docker_build_args()
{
    etestmsg "Creating Dockerfile"
	cat <<-'END' >Dockerfile
	FROM alpine:edge
	ARG ARTIST
	ARG SONG
	RUN echo "${ARTIST}/${SONG}"
	END
    cat Dockerfile

    etestmsg "Building docker image (pretend)"
    $(tryrc docker_build           \
        --pretend                  \
        --name "elibs/ebash"       \
        --build-arg "ARTIST=James" \
        --build-arg "SONG=Laid"    \
    )
    assert_eq 1 "${rc}"

    etestmsg "Validating docker_build artifacts"
    assert_exists \
        ".work/docker/ebash/dockerfile" \
        ".work/docker/ebash/sha"        \
        ".work/docker/ebash/sha.func"   \
        ".work/docker/ebash/sha.short"  \
        ".work/docker/ebash/sha.detail" \

    etestmsg "Validating provided build_args are NOT interpolated"
    assert_true  diff "Dockerfile"            ".work/docker/ebash/dockerfile"
    assert_true  grep "ARG ARTIST"            ".work/docker/ebash/dockerfile"
    assert_true  grep "ARG SONG"              ".work/docker/ebash/dockerfile"
    assert_false grep 'RUN echo "James/Laid"' ".work/docker/ebash/dockerfile"
}

# Verify that provided ibuild args are interpolated
ETEST_docker_ibuild_args()
{
    etestmsg "Creating Dockerfile"
	cat <<-'END' >Dockerfile
	FROM alpine:edge
	ARG ARTIST
	ARG SONG
	RUN echo "${ARTIST}/${SONG}"
	END
    cat Dockerfile

    etestmsg "Building docker image (pretend)"
    $(tryrc docker_build           \
        --pretend                  \
        --name "elibs/ebash"       \
        --ibuild-arg "ARTIST=James" \
        --ibuild-arg "SONG=Laid"    \
    )
    assert_eq 1 "${rc}"

    etestmsg "Validating docker_build artifacts"
    assert_exists \
        ".work/docker/ebash/dockerfile" \
        ".work/docker/ebash/sha"        \
        ".work/docker/ebash/sha.func"   \
        ".work/docker/ebash/sha.short"  \
        ".work/docker/ebash/sha.detail" \

    etestmsg "Validating provided ibuild_args are interpolated"
    assert_false diff "Dockerfile"            ".work/docker/ebash/dockerfile"
    assert_false grep "ARG ARTIST"            ".work/docker/ebash/dockerfile"
    assert_false grep "ARG SONG"              ".work/docker/ebash/dockerfile"
    assert_true  grep 'RUN echo "James/Laid"' ".work/docker/ebash/dockerfile"
}

ETEST_docker_build_cache_from()
{
    etestmsg "Creating Dockerfile"
	cat <<-END >Dockerfile
	FROM alpine:edge
	ENV CREATOR etest-$$
	END
    cat Dockerfile

    etestmsg "Building docker image"
    docker_build --name "elibs/ebash" --cache-from "alpine:latest"

    etestmsg "Validating docker_build artifacts"
    assert_exists \
        ".work/docker/ebash/build.log"  \
        ".work/docker/ebash/dockerfile" \
        ".work/docker/ebash/history"    \
        ".work/docker/ebash/image"      \
        ".work/docker/ebash/inspect"    \
        ".work/docker/ebash/options"    \
        ".work/docker/ebash/sha"        \
        ".work/docker/ebash/sha.func"   \
        ".work/docker/ebash/sha.short"  \
        ".work/docker/ebash/sha.detail" \

    etestmsg "Validating Docker Image was built"
    image="$(cat .work/docker/ebash/image)"
    etestmsg "$(lval image)"
    trap_add "docker rmi ${image}"

    assert_docker_image_exists "${image}"
}

# Custom dockerfile name
ETEST_docker_build_custom_dockerfile()
{
    local file="Dockerfile.foobar"
    etestmsg "Creating Dockerfile=${file}"
	cat <<-END >${file}
	FROM alpine:edge
	ENV CREATOR etest-$$
	END
    cat "${file}"

    etestmsg "Building docker image"
    docker_build             \
        --name "elibs/ebash" \
        --file "${file}"

    etestmsg "Validating docker_build artifacts"
    assert_exists \
        ".work/docker/ebash/build.log"  \
        ".work/docker/ebash/dockerfile" \
        ".work/docker/ebash/history"    \
        ".work/docker/ebash/image"      \
        ".work/docker/ebash/inspect"    \
        ".work/docker/ebash/options"    \
        ".work/docker/ebash/sha"        \
        ".work/docker/ebash/sha.func"   \
        ".work/docker/ebash/sha.short"  \
        ".work/docker/ebash/sha.detail" \

    etestmsg "Validating Docker Image was built"
    image="$(cat .work/docker/ebash/image)"
    etestmsg "$(lval image)"
    trap_add "docker rmi ${image}"

    assert_docker_image_exists "${image}"
}

# Custom dockerfile and custom artifact name
ETEST_docker_build_custom_dockerfile()
{
    local file="Dockerfile.foobar"
    etestmsg "Creating Dockerfile=${file}"
	cat <<-END >${file}
	FROM alpine:edge
	ENV CREATOR etest-$$
	END
    cat "${file}"

    etestmsg "Building docker image"
    docker_build                   \
        --name "elibs_ebash"       \
        --file "${file}"

    etestmsg "Validating docker_build artifacts"
    assert_exists \
        ".work/docker/elibs_ebash/build.log"  \
        ".work/docker/elibs_ebash/dockerfile" \
        ".work/docker/elibs_ebash/history"    \
        ".work/docker/elibs_ebash/image"      \
        ".work/docker/elibs_ebash/inspect"    \
        ".work/docker/elibs_ebash/options"    \
        ".work/docker/elibs_ebash/sha"        \
        ".work/docker/elibs_ebash/sha.func"   \
        ".work/docker/elibs_ebash/sha.short"  \
        ".work/docker/elibs_ebash/sha.detail" \

    etestmsg "Validating Docker Image was built"
    image="$(cat .work/docker/elibs_ebash/image)"
    etestmsg "$(lval image)"
    trap_add "docker rmi ${image}"

    assert_docker_image_exists "${image}"
}

ETEST_docker_custom_shafunc()
{
    etestmsg "Creating Dockerfile"
	cat <<-END >Dockerfile
	FROM alpine:edge
	ENV CREATOR etest-$$
	END
    cat Dockerfile

    etestmsg "Building docker image"
    docker_build             \
        --name "elibs/ebash" \
        --shafunc sha512

    assert_eq "sha512" "$(cat .work/docker/ebash/sha.func)"

    etestmsg "Validating docker_build artifacts"
    assert_exists \
        ".work/docker/ebash/build.log"  \
        ".work/docker/ebash/dockerfile" \
        ".work/docker/ebash/history"    \
        ".work/docker/ebash/image"      \
        ".work/docker/ebash/inspect"    \
        ".work/docker/ebash/options"    \
        ".work/docker/ebash/sha"        \
        ".work/docker/ebash/sha.func"   \
        ".work/docker/ebash/sha.short"  \
        ".work/docker/ebash/sha.detail" \

    etestmsg "Validating Docker Image was built"
    image="$(cat .work/docker/ebash/image)"
    etestmsg "$(lval image)"
    trap_add "docker rmi ${image}"

    assert_docker_image_exists "${image}"
}

# Verify we can provide multiple additional tags and that all get created
ETEST_docker_build_tags()
{
    etestmsg "Creating Dockerfile"
	cat <<-END >Dockerfile
	FROM alpine:edge
	ENV CREATOR etest-$$
	END
    cat Dockerfile

    local tags=(
        "elibs/ebash:etest-$$-tag1"
        "elibs/ebash:etest-$$-tag2"
        "elibs/ebash-cicd:$$"
        "foo"
        "bar"
        "zap"
    )

    etestmsg "Building docker image"
    eval "docker_build --name elibs/ebash $(array_join --before tags ' --tag ')"
    trap_add "docker rmi ${tags[*]}"

    etestmsg "Validating docker_build artifacts"
    assert_exists \
        ".work/docker/ebash/build.log"  \
        ".work/docker/ebash/dockerfile" \
        ".work/docker/ebash/history"    \
        ".work/docker/ebash/image"      \
        ".work/docker/ebash/inspect"    \
        ".work/docker/ebash/options"    \
        ".work/docker/ebash/sha"        \
        ".work/docker/ebash/sha.func"   \
        ".work/docker/ebash/sha.short"  \
        ".work/docker/ebash/sha.detail" \

    etestmsg "Validating Docker Image was built"
    image="$(cat .work/docker/ebash/image)"
    etestmsg "$(lval image)"
    trap_add "docker rmi ${image}"
    assert_docker_image_exists "${image}"

    etestmsg "Validating all tags were built"
    for tag in "${tags[@]}"; do
        echo "${tag}"
        assert_docker_image_exists "${tag}"
    done
}

# Verify pushing tags works properly. Mock out docker() so that we don't have to actually have an upstream to push to.
ETEST_docker_build_tags_push()
{
    etestmsg "Creating Dockerfile"
	cat <<-END >Dockerfile
	FROM alpine:edge
	ENV CREATOR etest-$$
	END
    cat Dockerfile

    local tags=(
        "elibs/ebash:etest-$$-tag1"
        "elibs/ebash:etest-$$-tag2"
        "elibs/ebash-cicd:$$"
        "foo"
        "bar"
        "zap"
    )

    etestmsg "Building docker image"
    eval "docker_build --name elibs/ebash --username neo --password matrix $(array_join --before tags ' --tag ') --push"

    etestmsg "Validating docker_build artifacts"
    assert_exists \
        ".work/docker/ebash/build.log"  \
        ".work/docker/ebash/dockerfile" \
        ".work/docker/ebash/history"    \
        ".work/docker/ebash/image"      \
        ".work/docker/ebash/inspect"    \
        ".work/docker/ebash/options"    \
        ".work/docker/ebash/sha"        \
        ".work/docker/ebash/sha.func"   \
        ".work/docker/ebash/sha.short"  \
        ".work/docker/ebash/sha.detail" \

    etestmsg "Validating Docker Image was built"
    image="$(cat .work/docker/ebash/image)"
    etestmsg "$(lval image)"
    trap_add "docker rmi ${image}"
    assert_docker_image_exists "${image}"

    etestmsg "Validating all tags were built"
    for tag in "${tags[@]}"; do
        echo "${tag}"
        assert_docker_image_exists "${tag}"
    done

    etestmsg "Validating all tags were pushed"
    array_sort tags
    array_sort docker_tags_pushed
    etestmsg "$(lval tags docker_tags_pushed)"
    for tag in "${tags[@]}"; do
        array_contains docker_tags_pushed "${tag}"
    done
}

# Verify if we create the same docker image multiple times in a row that it does NOT build it again but instead reuses
# the one we've locally built.
ETEST_docker_build_twice()
{
    etestmsg "Creating Dockerfile"
	cat <<-END >Dockerfile
	FROM alpine:edge
	ENV CREATOR etest-$$
	END
    cat Dockerfile

    etestmsg "Building docker image"
    docker_build --name "elibs/ebash"

    etestmsg "Validating docker_build artifacts"
    assert_exists \
        ".work/docker/ebash/build.log"  \
        ".work/docker/ebash/dockerfile" \
        ".work/docker/ebash/history"    \
        ".work/docker/ebash/image"      \
        ".work/docker/ebash/inspect"    \
        ".work/docker/ebash/options"    \
        ".work/docker/ebash/sha"        \
        ".work/docker/ebash/sha.detail" \
        ".work/docker/ebash/sha.func"   \
        ".work/docker/ebash/sha.short"  \

    etestmsg "Validating Docker Image was built"
    image="$(cat .work/docker/ebash/image)"
    etestmsg "$(lval image)"
    assert_docker_image_exists "${image}"
    trap_add "docker rmi ${image}"

    for part in build.log dockerfile history image inspect sha sha.short sha.detail; do
        cp ".work/docker/ebash/${part}" ".work/docker/ebash/${part}.orig"
    done
    grep 'pretend="0"' ".work/docker/ebash/options"

    etestmsg "Building docker image (AGAIN)"
    docker_build         \
        --pretend        \
        --name "elibs/ebash"

    for part in build.log dockerfile history image inspect sha sha.short sha.detail; do
        etestmsg "Checking ${part}"
        # Depending on how fast this test runs, the output may say '1 second ago' or '2 seconds ago' which can cause
        # a false-positive failure. We don't actually care about that part of the history file so just remove it from
        # both files before we diff.
        if [[ "${part}" == "history" ]]; then

            diff ".work/docker/ebash/${part}.orig" ".work/docker/ebash/${part}" || true

            sed -i -e 's|[0-9]\+ seconds* ago\s*|1 second ago        |' \
                   -e 's|Less than a second ago\s*|1 second ago        |' \
                ".work/docker/ebash/${part}.orig" ".work/docker/ebash/${part}"
        fi

        diff ".work/docker/ebash/${part}.orig" ".work/docker/ebash/${part}"
    done
    grep 'pretend="1"' ".work/docker/ebash/options"

    created_expect=$(jq --raw-output '.[].Created' ".work/docker/ebash/inspect")
    created_actual=$(docker inspect --type image ${image} | jq --raw-output '.[].Created')
    assert_eq "${created_expect}" "${created_actual}"
}

# Verify if we make a small change to the Dockerfile that we won't reuse the previously built image.
ETEST_docker_build_twice_changed()
{
    etestmsg "Creating Dockerfile"
	cat <<-END >Dockerfile
	FROM alpine:edge
	ENV CREATOR etest-$$
	END
    cat Dockerfile

    etestmsg "Building docker image"
    docker_build --name "elibs/ebash"

    etestmsg "Validating docker_build artifacts"
    assert_exists                       \
        ".work/docker/ebash/build.log"  \
        ".work/docker/ebash/dockerfile" \
        ".work/docker/ebash/history"    \
        ".work/docker/ebash/image"      \
        ".work/docker/ebash/inspect"    \
        ".work/docker/ebash/options"    \
        ".work/docker/ebash/sha"        \
        ".work/docker/ebash/sha.func"   \
        ".work/docker/ebash/sha.short"  \
        ".work/docker/ebash/sha.detail" \

    etestmsg "Validating Docker Image was built"
    image="$(cat .work/docker/ebash/image)"
    etestmsg "$(lval image)"
    assert_docker_image_exists "${image}"
    trap_add "docker rmi ${image}"

    for part in dockerfile sha sha.short sha.detail; do
        cp ".work/docker/ebash/${part}" ".work/docker/ebash/${part}.orig"
    done

    etestmsg "Modifying Dockerfile"
    cat <<-END >Dockerfile
	FROM alpine:edge
	ENV CREATOR etest-$$
	ENV TIMESTAMP $(etimestamp)
	END
    cat Dockerfile

    etestmsg "Building docker image (AGAIN)"
    $(tryrc docker_build     \
        --pretend            \
        --name "elibs/ebash" \
    )

    assert_eq 1 "${rc}"

    for part in dockerfile sha sha.short sha.detail; do
        assert_false diff ".work/docker/ebash/${part}.orig" ".work/docker/ebash/${part}"
    done
}

ETEST_docker_build_overlay()
{
    etestmsg "Creating Dockerfile"
	cat <<-END >Dockerfile
	FROM ubuntu:20.04
	ENV CREATOR etest-$$
	ENTRYPOINT ["sleep", "infinity"]
	END
    cat Dockerfile

    mkdir -p "overlay/usr/local/bin" "overlay/etc"
    touch "overlay/usr/local/bin/foo"
    touch "overlay/etc/foo.cfg"

    etestmsg "Building docker image"
    docker_build \
        --name "elibs/ebash" \
        --overlay ebash      \
        --overlay systemd    \
        --overlay selinux    \
        --overlay rsyslog    \
        --overlay-tree overlay

    cat ".work/docker/ebash/dockerfile"

    etestmsg "Validating options file"
    cat ".work/docker/ebash/options"
    options_lines=(
        'build_arg=()'
        'cache="1"'
        'cache_from=""'
        'file="Dockerfile"'
        'ibuild_arg=()'
        'name="elibs/ebash"'
        'overlay=("ebash" "systemd" "selinux" "rsyslog")'
        'overlay_tree="overlay"'
        'password=""'
        'pretend="0"'
        'pull="0"'
        'push="0"'
        'registry="https://index.docker.io/v1/"'
        'shafunc="sha256"'
        'tag=()'
        'username=""'
        'workdir=".work/docker"'
    )

    diff --unified <(echo "$(array_join_nl options_lines)") ".work/docker/ebash/options"

    local overdir=".work/docker/ebash/overlay"
    etestmsg "Inspecting $(lval overdir)"
    find "${overdir}" -ls
    assert_exists "${overdir}/custom"
    assert_exists "${overdir}/ebash"
    assert_exists "${overdir}/systemd"
    assert_exists "${overdir}/selinux"
    assert_exists "${overdir}/rsyslog"

    etestmsg "Validating dockerfile COPY directives"
    grep 'COPY "'${overdir}'/custom" "/"'  ".work/docker/ebash/dockerfile"
    grep 'COPY "'${overdir}'/ebash" "/"'   ".work/docker/ebash/dockerfile"
    grep 'COPY "'${overdir}'/systemd" "/"' ".work/docker/ebash/dockerfile"
    grep 'COPY "'${overdir}'/selinux" "/"' ".work/docker/ebash/dockerfile"
    grep 'COPY "'${overdir}'/rsyslog" "/"' ".work/docker/ebash/dockerfile"

    etestmsg "Validating overlay entries in depends_sha"
    grep "${overdir}/custom/usr/local/bin/foo"          ".work/docker/ebash/sha.detail"
    grep "${overdir}/custom/etc/foo.cfg"                ".work/docker/ebash/sha.detail"
    grep "${overdir}/ebash"                             ".work/docker/ebash/sha.detail"
    grep "${overdir}/selinux/etc/selinux/config"        ".work/docker/ebash/sha.detail"
    grep "${overdir}/systemd/usr/local/bin/systemctl"   ".work/docker/ebash/sha.detail"
    grep "${overdir}/systemd/usr/local/bin/timedatectl" ".work/docker/ebash/sha.detail"
    grep "${overdir}/rsyslog/etc/rsyslog.conf"          ".work/docker/ebash/sha.detail"

    etestmsg "Validating overlay contents inside docker image"
    image="$(cat .work/docker/ebash/image)"
    container_id=$(docker run --detach --network host "${image}")
    trap_add "docker kill ${container_id}"

    validate_paths=(
        "/etc/foo.cfg"
        "/etc/rsyslog.conf"
        "/etc/selinux/config"
        "/opt/ebash"
        "/opt/ebash/bin/ebash"
        "/opt/ebash/bin/einfo"
        "/usr/local/bin/ebash"
        "/usr/local/bin/foo"
        "/usr/local/bin/systemctl"
        "/usr/local/bin/timedatectl"
    )

    for entry in "${validate_paths[@]}"; do
        echo "${entry}"
        docker exec "${container_id}" bash -c "[[ -e ${entry} ]]"
    done
}

ETEST_docker_build_overlay_systemctl_wrapper()
{
    # For no explicable reason, this test is very flaky on Centos:8 but perfectly stable on all other distros.
    $(skip_if "os_distro centos && os_release 8")
    $(skip_if "os_distro rocky  && os_release 8.4")

    EDEBUG=daemon

    etestmsg "Creating init"
	cat <<-'END' >init
	#!/bin/bash

	$(ebash --source)

	EDEBUG=daemon

	# Block all signals that would otherwise cause us to exit similar to real 'init'
	disable_signals

	daemon_init sleeper1 \
	    autostart="yes"  \
	    cmdline="sleep infinity"

	daemon_init sleeper2 \
	    autostart="yes"  \
	    cmdline="sleep infinity"

	# Process reaping
	while true; do
		wait
	done
	END
    cat init
    chmod +x init

    etestmsg "Creating Dockerfile"
	cat <<-END >Dockerfile
	FROM ubuntu:20.04
	COPY "init" "/init"
	ENTRYPOINT ["/init"]
	END
    cat Dockerfile

    etestmsg "Building docker image"
    docker_build \
        --name "elibs/ebash"                   \
        --file "${TEST_DIR_OUTPUT}/Dockerfile" \
        --overlay "ebash"                      \
        --overlay "systemd"
    cat ".work/docker/ebash/dockerfile"
    find ".work/docker/ebash/overlay" -ls

    etestmsg "Running docker container"
    image="$(cat .work/docker/ebash/image)"
    container_id=$(docker run --detach --network host "${image}")
    trap_add "docker kill ${container_id}"
    eretry --max-timeout 30s docker exec "${container_id}" bash -c "[[ -e /usr/local/bin/systemctl ]]"

    etestmsg "Validate systemctl wrapper"
    docker exec "${container_id}" systemctl status sleeper1
    docker exec "${container_id}" systemctl is-active sleeper1
    docker exec "${container_id}" systemctl status sleeper2
    docker exec "${container_id}" systemctl is-active sleeper2

    etestmsg "Stopping sleeper1 and sleeper2"
    docker exec "${container_id}" systemctl stop sleeper1
    docker exec "${container_id}" systemctl stop sleeper2
    assert_false docker exec "${container_id}" systemctl status sleeper1
    assert_false docker exec "${container_id}" systemctl status sleeper2

    etestmsg "Starting sleeper1"
    docker exec "${container_id}" systemctl start sleeper1
    eretry --max-timeout 30s docker exec "${container_id}" systemctl status sleeper1

    etestmsg "Restarting sleeper1"
    docker exec "${container_id}" systemctl restart sleeper1
    eretry --max-timeout 30s docker exec "${container_id}" systemctl status sleeper1

    etestmsg "Restarting sleeper2"
    docker exec "${container_id}" systemctl restart sleeper2
    eretry --max-timeout 30s docker exec "${container_id}" systemctl status sleeper2
}

ETEST_docker_build_overlay_systemctl_wrapper_enabled()
{
    # For no explicable reason, this test is very flaky on Centos:8 but perfectly stable on all other distros.
    $(skip_if "os_distro centos && os_release 8")
    $(skip_if "os_distro rocky  && os_release 8.4")

    EDEBUG=daemon

    etestmsg "Creating init"
	cat <<-'END' >init
	#!/bin/bash

	$(ebash --source)

	EDEBUG=daemon

	# Block all signals that would otherwise cause us to exit similar to real 'init'
	disable_signals

	daemon_init sleeper1         \
	    autostart="false"        \
	    cmdline="sleep infinity" \
	    enabled="false"

	# Process reaping
	while true; do
		wait
	done
	END
    cat init
    chmod +x init

    etestmsg "Creating Dockerfile"
	cat <<-END >Dockerfile
	FROM ubuntu:20.04
	COPY "init" "/init"
	ENTRYPOINT ["/init"]
	END
    cat Dockerfile

    etestmsg "Building docker image"
    docker_build \
        --name "elibs/ebash"                   \
        --file "${TEST_DIR_OUTPUT}/Dockerfile" \
        --overlay "ebash"                      \
        --overlay "systemd"
    cat ".work/docker/ebash/dockerfile"
    find ".work/docker/ebash/overlay" -ls

    etestmsg "Running docker container"
    image="$(cat .work/docker/ebash/image)"
    container_id=$(docker run --detach --network host "${image}")
    trap_add "docker kill ${container_id}"
    eretry --max-timeout 30s docker exec "${container_id}" bash -c "[[ -e /usr/local/bin/systemctl ]]"

    etestmsg "Verifying daemon is not enabled and not running"
    assert_false docker exec "${container_id}" systemctl status sleeper1
    assert_false docker exec "${container_id}" systemctl is-active sleeper1
    assert_false docker exec "${container_id}" systemctl is-enabled sleeper1

    etestmsg "Enable and Start Daemon"
    docker exec "${container_id}" systemctl enable --now sleeper1
    docker exec "${container_id}" systemctl is-active sleeper1
    docker exec "${container_id}" systemctl is-enabled sleeper1

    etestmsg "Disable and Stop Daemon"
    docker exec "${container_id}" systemctl disable --now sleeper1
    assert_false docker exec "${container_id}" systemctl status sleeper1
    assert_false docker exec "${container_id}" systemctl is-active sleeper1
    assert_false docker exec "${container_id}" systemctl is-enabled sleeper1
}

ETEST_docker_depends_sha()
{
    etestmsg "Creating Dockerfile"
	cat <<-END >Dockerfile
	FROM alpine:edge
	ENV CREATOR etest-$$
	END
    cat Dockerfile

    mkdir -p "overlay/usr/local/bin" "overlay/etc"
    touch "overlay/usr/local/bin/foo"
    touch "overlay/etc/foo.cfg"

    etestmsg "Computing Dependency SHA"
    docker_depends_sha \
        --name "elibs/ebash" \
        --overlay systemd    \
        --overlay selinux    \
        --overlay rsyslog    \
        --overlay-tree overlay

    cat ".work/docker/ebash/dockerfile"

    etestmsg "Validating depends_sha artifacts"
    assert_exists \
        ".work/docker/ebash/dockerfile" \
        ".work/docker/ebash/options"    \
        ".work/docker/ebash/sha"        \
        ".work/docker/ebash/sha.func"   \
        ".work/docker/ebash/sha.short"  \
        ".work/docker/ebash/sha.detail" \

    etestmsg "Validating Docker Image was not built"
    image="elibs/ebash:$(cat .work/docker/ebash/sha.short)"
    etestmsg "$(lval image)"
    assert_docker_image_not_exists "${image}"

    # Validate dependency SHA
    etestmsg "Validating SHA function"
    assert_eq "sha256" "$(cat .work/docker/ebash/sha.func)"
    cat ".work/docker/ebash/sha"

    etestmsg "Details"
    cat ".work/docker/ebash/sha.detail"
    depends=(
        ".work/docker/ebash/dockerfile"
        ".work/docker/ebash/overlay/custom/etc/foo.cfg"
        ".work/docker/ebash/overlay/custom/usr/local/bin/foo"
        ".work/docker/ebash/overlay/rsyslog/etc/rsyslog.conf"
        ".work/docker/ebash/overlay/selinux/etc/selinux/config"
        ".work/docker/ebash/overlay/systemd/usr/local/bin/systemctl"
        ".work/docker/ebash/overlay/systemd/usr/local/bin/timedatectl"
    )

    etestmsg "Showing local dependency tree"
    find ".work/docker/ebash/overlay"

    expect=()
    for depend in "${depends[@]}"; do
        expect+=( "${depend}@sha256:$(sha256sum "${depend}" | awk '{print $1}')" )
    done

    etestmsg "Expected SHA Details"
    expected=$(array_join_nl expect)
    assert_eq "${expected}" "$(cat .work/docker/ebash/sha.detail)"

    etestmsg "Roll-up SHA"
    expected=$(sha256sum .work/docker/ebash/sha.detail | awk '{print $1}')
    assert_eq "sha256:${expected}" "$(cat .work/docker/ebash/sha)"
}

ETEST_docker_depends_sha_exclude()
{
    etestmsg "Creating Dockerfile"
	cat <<-END >Dockerfile
	FROM alpine:edge
	ENV CREATOR etest-$$
	COPY foo /foo
	END
    cat Dockerfile

    etestmsg "Creating dockerignore"
    mkdir foo foo/baz foo/null foo/null/work
    touch \
        foo/bar        \
        foo/zap        \
        foo/a.o        \
        foo/b.o        \
        foo/baz/README \
        foo/baz/dogs.o \
        foo/baz/cats.o \
        foo/null/a     \
        foo/null/b     \
        foo/null/work/ok
    echo '**/*.o'   >> .dockerignore
    echo 'foo/null' >> .dockerignore
    cat ".dockerignore"

    etestmsg "Computing Dependency SHA"
    docker_depends_sha \
        --name "elibs/ebash" \

    cat ".work/docker/ebash/dockerfile"

    etestmsg "Validating depends_sha artifacts"
    assert_exists \
        ".work/docker/ebash/dockerfile" \
        ".work/docker/ebash/options"    \
        ".work/docker/ebash/sha"        \
        ".work/docker/ebash/sha.func"   \
        ".work/docker/ebash/sha.short"  \
        ".work/docker/ebash/sha.detail" \

    etestmsg "Validating Docker Image was not built"
    image="elibs/ebash:$(cat .work/docker/ebash/sha.short)"
    etestmsg "$(lval image)"
    assert_docker_image_not_exists "${image}"

    # Validate dependency SHA
    etestmsg "Validating SHA function"
    assert_eq "sha256" "$(cat .work/docker/ebash/sha.func)"
    cat ".work/docker/ebash/sha"

    etestmsg "Details"
    cat ".work/docker/ebash/sha.detail"
    depends=(
        ".work/docker/ebash/dockerfile"
        "foo/bar"
        "foo/baz/README"
        "foo/zap"
    )

    etestmsg "Showing local dependency tree"
    find ".work/docker/ebash/overlay"

    expect=()
    for depend in "${depends[@]}"; do
        expect+=( "${depend}@sha256:$(sha256sum "${depend}" | awk '{print $1}')" )
    done
    array_sort expect

    etestmsg "Expected SHA Details"
    expected=$(array_join_nl expect)
    assert_eq "${expected}" "$(cat .work/docker/ebash/sha.detail)"

    etestmsg "Roll-up SHA"
    expected=$(sha256sum .work/docker/ebash/sha.detail | awk '{print $1}')
    assert_eq "sha256:${expected}" "$(cat .work/docker/ebash/sha)"
}

ETEST_docker_export_tgz()
{
    unset docker

    etestmsg "Creating Dockerfile"
	cat <<-END >Dockerfile
	FROM alpine:edge
	ENV CREATOR etest-$$
	END
    cat Dockerfile

    etestmsg "Building docker image"
    docker_build --name "elibs/ebash"

    etestmsg "Validating Docker Image was built"
    image="$(cat .work/docker/ebash/image)"
    trap_add "docker rmi ${image} &>/dev/null || true"
    assert_docker_image_exists "${image}"

    etestmsg "Converting docker image to tgz"
    docker_export "${image}" image.tgz
}

ETEST_docker_export_squashfs()
{
    # This test only works on linux as it requires squashfs.
    if ! os Linux; then
        ewarn "Skipping ${FUNCNAME} on non-Linux OS."
        return 0
    fi

    unset docker

    etestmsg "Creating Dockerfile"
	cat <<-END >Dockerfile
	FROM alpine:edge
	ENV CREATOR etest-$$
	END
    cat Dockerfile

    etestmsg "Building docker image"
    docker_build --name "elibs/ebash"

    etestmsg "Validating Docker Image was built"
    image="$(cat .work/docker/ebash/image)"
    trap_add "docker rmi ${image} &>/dev/null || true"
    assert_docker_image_exists "${image}"

    etestmsg "Converting docker image to squashfs"
    docker_export "${image}" image.squashfs
}

ETEST_docker_run_envlist()
{
    emock "docker"

    # Set some environment variables we want to pass through into docker
    etestmsg "Creating dummy variables"
    FOO=1
    BAR=2
    ZAP="This one has spaces in it"
    DAB="${PATH}"

    etestmsg "Calling docker_run with env list"
    docker_run --interactive=no --envlist 'FOO BAR ZAP DAB BLAH=PATH ARG=1 ARG2="Another with spaces"'

    assert_emock_called "docker" 1

    assert_emock_called_with "docker" 0 run     \
        --env ARG=1                             \
        --env ARG2="Another with spaces"        \
        --env BAR=2                             \
        --env BLAH="${PATH}"                    \
        --env DAB="${PATH}"                     \
        --env FOO=1                             \
        --env ZAP="This one has spaces in it"
}

ETEST_docker_run_nested()
{
    emock "docker"

    etestmsg "Calling docker_run with --nested"
    docker_run --interactive=no --nested

    assert_emock_called "docker" 1

    assert_emock_called_with "docker" 0 run     \
        --mount "type=bind,source=/var/run/docker.sock,target=/var/run/docker.sock"
}

ETEST_docker_run_copy_to_volume()
{
    emock "docker"

    etestmsg "Calling docker_run with multiple copy_to_volume"

    # Run this inside a subshell so that we can ensure the traps are getting called to remove the ephemeral volumes
    (
        docker_run --interactive=no \
            --copy-to-volume "foo:foo:/foo"                    \
            --copy-to-volume "data:/home/marshall/data:/data"  \
            --copy-to-volume "ebash:/home/ebash:/baggins"      \
    )

    assert_emock_called "docker" 16

    assert_emock_called_with "docker" 0 \
        rm /foo

    assert_emock_called_with "docker" 1 \
        container create        \
        --name foo              \
        -v foo:/foo             \
        busybox

    assert_emock_called_with "docker" 2 \
        cp "foo/."              \
        "foo:/foo"

    assert_emock_called_with "docker" 3 \
        rm /data

    assert_emock_called_with "docker" 4 \
        container create        \
        --name data             \
        -v data:/data           \
        busybox

    assert_emock_called_with "docker" 5 \
        cp "/home/marshall/data/." "data:/data"

    assert_emock_called_with "docker" 6 \
        rm /ebash

    assert_emock_called_with "docker" 7 \
        container create        \
        --name ebash            \
        -v ebash:/baggins       \
        busybox

    assert_emock_called_with "docker" 8 \
        cp "/home/ebash/." "ebash:/baggins"

    assert_emock_called_with "docker" 9 \
        run                     \
        --volume=foo:/foo       \
        --volume=data:/data     \
        --volume=ebash:/baggins \

    assert_emock_called_with "docker" 10 \
        rm --volumes ebash

    assert_emock_called_with "docker" 11 \
        volume rm ebash

    assert_emock_called_with "docker" 12 \
        rm --volumes data

    assert_emock_called_with "docker" 13 \
        volume rm data

    assert_emock_called_with "docker" 14 \
        rm --volumes foo

    assert_emock_called_with "docker" 15 \
        volume rm foo
}

ETEST_docker_run_copy_from_volume()
{
    emock "docker"
    trap_add "eunmock docker"

    emock "rm"
    trap_add "eunmock rm"

    etestmsg "Calling docker_run with multiple copy_from_volume"

    # Run this inside a subshell so that we can ensure the traps are getting called to remove the ephemeral volumes
    (
        docker_run --interactive=no \
            --copy-from-volume "foo:/foo:foo"                    \
            --copy-from-volume-delete "foo/bad"                  \
            --copy-from-volume "data:/home/marshall/data:data"   \
            --copy-from-volume "ebash:/home/ebash:/home/baggins" \
            --copy-from-volume-delete "/home/baggins/trash"      \
    )

    assert_emock_called "docker" 4

    assert_emock_called_with "docker" 0 \
        run                     \

    assert_emock_called_with "docker" 1 \
        cp "ebash:/home/ebash/." "/home/baggins"

    assert_emock_called_with "docker" 2 \
        cp "data:/home/marshall/data/." "data"

    assert_emock_called_with "docker" 3 \
        cp "foo:/foo/." "foo"

    etestmsg "Verifying post-copy deletes called"
    assert_emock_called "rm" 2
    assert_emock_called_with "rm" 0 \
        --recursive --force "/home/baggins/trash"
    assert_emock_called_with "rm" 1 \
        --recursive --force "foo/bad"
}

ETEST_docker_run_passthrough_args()
{
    emock "docker"

    etestmsg "Calling docker_run with passthrough args"

    docker_run --interactive=no -- \
        --init          \
        --tty           \
        --network host  \
        --privileged    \
        --rm            \
        --workdir /ebash

    assert_emock_called "docker" 1

    etestmsg "Verifying args"
    assert_emock_called_with "docker" 0 \
        run             \
        --init          \
        --tty           \
        --network host  \
        --privileged    \
        --rm            \
        --workdir /ebash
}

ETEST_docker_run_ssh_port_forward()
{
    export DOCKER_HOST="ssh://someuser@somehost:1234"

    emock "docker"
    emock "ssh"

    docker_run --ssh-port-forward 8080

    assert_emock_called "docker" 1
    assert_emock_called_with "docker" 0 \
        run           \
        --interactive

    assert_emock_called "ssh" 1
    assert_emock_called_with "ssh" 0  \
        -NL                           \
        127.0.0.1:8080:127.0.0.1:8080 \
        someuser@somehost:1234
}

ETEST_docker_run_ssh_port_forward_multiple()
{
    export DOCKER_HOST="ssh://someuser@somehost"

    emock "docker"
    emock "ssh"

    docker_run --ssh-port-forward 8080 --ssh-port-forward 2222

    assert_emock_called "docker" 1
    assert_emock_called_with "docker" 0 \
        run           \
        --interactive

    assert_emock_called "ssh" 2
    assert_emock_called_with "ssh" 0  \
        -NL                           \
        127.0.0.1:8080:127.0.0.1:8080 \
        someuser@somehost:22

    assert_emock_called_with "ssh" 1  \
        -NL                           \
        127.0.0.1:2222:127.0.0.1:2222 \
        someuser@somehost:22
}

ETEST_docker_run_ssh_port_forward_diff()
{
    export DOCKER_HOST="ssh://someuser@somehost:1234"

    emock "docker"
    emock "ssh"

    docker_run --ssh-port-forward 80:8080

    assert_emock_called "docker" 1
    assert_emock_called_with "docker" 0 \
        run           \
        --interactive

    assert_emock_called "ssh" 1
    assert_emock_called_with "ssh" 0 \
        -NL                          \
        127.0.0.1:80:127.0.0.1:8080  \
        someuser@somehost:1234
}

ETEST_docker_run_ssh_port_forward_diff_multiple()
{
    export DOCKER_HOST="ssh://someuser@somehost"

    emock "docker"
    emock "ssh"

    docker_run --ssh-port-forward 80:8080 --ssh-port-forward 22:2222

    assert_emock_called "docker" 1
    assert_emock_called_with "docker" 0 \
        run           \
        --interactive

    assert_emock_called "ssh" 2
    assert_emock_called_with "ssh" 0 \
        -NL                          \
        127.0.0.1:80:127.0.0.1:8080  \
        someuser@somehost:22

    assert_emock_called_with "ssh" 1 \
        -NL                          \
        127.0.0.1:22:127.0.0.1:2222  \
        someuser@somehost:22
}

ETEST_docker_compose_run_envlist()
{
    emock --stdout "tmp/file1" "mktemp"
    emock "docker-compose"

    # Set some environment variables we want to pass through into docker
    etestmsg "Creating dummy variables"
    FOO=1
    BAR=2
    ZAP="This one has spaces in it"
    DAB="${PATH}"

    etestmsg "Calling docker_compose_run with env list"
    docker_compose_run --no-wait --envlist 'FOO BAR ZAP DAB BLAH=PATH ARG=1 ARG2="Another with spaces"'

    assert_emock_called "docker-compose" 1

    assert_emock_called_with "docker-compose" 0 \
        --verbose                               \
        --file docker-compose.yml               \
        --env-file "tmp/file1"                  \
        run -T
}

ETEST_docker_compose_run_file()
{
    emock "docker-compose"

    etestmsg "Calling docker_compose_run with --file"

    docker_compose_run --no-wait --file "foo.yml"

    assert_emock_called "docker-compose" 1

    assert_emock_called_with "docker-compose" 0 \
        --verbose                               \
        --file foo.yml                          \
        run -T
}

ETEST_docker_compose_run_logfile()
{
    emock "docker-compose"

    etestmsg "Calling docker_compose_run with logfile"

    docker_compose_run --no-wait --logfile foo.log

    assert_emock_called "docker-compose" 1

    assert_emock_called_with "docker-compose" 0 \
        --verbose                               \
        --file docker-compose.yml               \
        run -T
}

ETEST_docker_compose_run_wait()
{
    emock "docker-compose"

    etestmsg "Calling docker_compose_run with --wait"

    docker_compose_run --wait

    assert_emock_called "docker-compose" 2

    assert_emock_called_with "docker-compose" 0 \
        --verbose                               \
        --file docker-compose.yml               \
        run -T

    assert_emock_called_with "docker-compose" 1 \
        --file docker-compose.yml               \
        ps --services
}

ETEST_docker_compose_run_wait_no_healthcheck()
{
    emock "docker-compose" '
    {
        if [[ ${called} -eq 1 ]]; then
            echo "minio"
        else
            echo "42"
        fi
    }'

    emock "docker" '
    {
        if [[ $1 == "inspect" ]]; then
            echo "[{\"State\": {\"Status\": \"running\"}}]"
        fi
    }'

    etestmsg "Calling docker_compose_run with --wait"
    docker_compose_run --wait

    assert_emock_called "docker-compose" 3

    assert_emock_called_with "docker-compose" 0 \
        --verbose                               \
        --file docker-compose.yml               \
        run -T

    assert_emock_called_with "docker-compose" 1 \
        --file docker-compose.yml               \
        ps --services

    assert_emock_called_with "docker-compose" 2 \
        --file docker-compose.yml               \
        ps -q minio

    assert_emock_called "docker" 2

    assert_emock_called_with "docker" 0 \
        inspect 42

    assert_emock_called_with "docker" 1 \
        inspect 42
}

ETEST_docker_compose_run_wait_with_healthcheck()
{
    emock "docker-compose" '
    {
        if [[ ${called} -eq 1 ]]; then
            echo "minio"
        else
            echo "42"
        fi
    }'

    emock "docker" '
    {
        if [[ ${called} -eq 0 ]]; then
            echo "[{\"State\": {\"Health\": {\"Status\": \"healthy\"}}}]"
        else
            echo "[{\"State\": {\"Status\": \"running\"}}]"
        fi
    }'

    etestmsg "Calling docker_compose_run with --wait"
    docker_compose_run --wait

    assert_emock_called "docker-compose" 3

    assert_emock_called_with "docker-compose" 0 \
        --verbose                               \
        --file docker-compose.yml               \
        run -T

    assert_emock_called_with "docker-compose" 1 \
        --file docker-compose.yml               \
        ps --services

    assert_emock_called_with "docker-compose" 2 \
        --file docker-compose.yml               \
        ps -q minio

    assert_emock_called "docker" 1

    assert_emock_called_with "docker" 0 \
        inspect 42
}

ETEST_docker_compose_run_default_wait_teardown()
{
    emock "docker-compose"

    etestmsg "Calling docker_compose_run with default --wait and --teardown"

    # Run this inside a subshell so that we can ensure the traps are getting called to remove the ephemeral volumes
    (
        docker_compose_run
    )

    assert_emock_called "docker-compose" 3

    assert_emock_called_with "docker-compose" 0 \
        --verbose                               \
        --file docker-compose.yml               \
        run -T

    assert_emock_called_with "docker-compose" 1 \
        --file docker-compose.yml               \
        ps --services

    etestmsg "Validating teardown args"
    assert_emock_called_with "docker-compose" 2 \
        --file docker-compose.yml               \
        down                                    \
        --volumes                               \
        --remove-orphans
}

ETEST_docker_compose_run_custom_wait_teardown()
{
    emock "docker-compose"

    etestmsg "Calling docker_compose_run with --wait and custom --teardown"

    # Run this inside a subshell so that we can ensure the traps are getting called to remove the ephemeral volumes
    (
        docker_compose_run --teardown "down --volumes"
    )

    assert_emock_called "docker-compose" 3

    assert_emock_called_with "docker-compose" 0 \
        --verbose                               \
        --file docker-compose.yml               \
        run -T

    assert_emock_called_with "docker-compose" 1 \
        --file docker-compose.yml               \
        ps --services

    etestmsg "Validating teardown args"
    assert_emock_called_with "docker-compose" 2 \
        --file docker-compose.yml               \
        down                                    \
        --volumes
}

ETEST_docker_compose_run_copy_to_volume()
{
    emock "docker"
    emock "docker-compose"

    etestmsg "Calling docker_compose_run with multiple copy_to_volume"

    # Run this inside a subshell so that we can ensure the traps are getting called to remove the ephemeral volumes
    (
        docker_compose_run                                     \
            --copy-to-volume "foo:foo:/foo"                    \
            --copy-to-volume "data:/home/marshall/data:/data"  \
            --copy-to-volume "ebash:/home/ebash:/baggins"      \
    )

    emock_dump_state "docker"
    assert_emock_called "docker" 15

    assert_emock_called_with "docker" 0 \
        rm "/foo"

    assert_emock_called_with "docker" 1 \
        container create        \
        --name foo              \
        -v foo:/foo             \
        busybox

    assert_emock_called_with "docker" 2 \
        cp "foo/."              \
        "foo:/foo"

    assert_emock_called_with "docker" 3 \
        rm "/data"

    assert_emock_called_with "docker" 4 \
        container create        \
        --name data             \
        -v data:/data           \
        busybox

    assert_emock_called_with "docker" 5 \
        cp "/home/marshall/data/." "data:/data"

    assert_emock_called_with "docker" 6 \
        rm "/ebash"

    assert_emock_called_with "docker" 7 \
        container create        \
        --name ebash            \
        -v ebash:/baggins       \
        busybox

    assert_emock_called_with "docker" 8 \
        cp "/home/ebash/." "ebash:/baggins"

    assert_emock_called_with "docker" 9 \
        rm --volumes ebash

    assert_emock_called_with "docker" 10 \
        volume rm ebash

    assert_emock_called_with "docker" 11 \
        rm --volumes data

    assert_emock_called_with "docker" 12 \
        volume rm data

    assert_emock_called_with "docker" 13 \
        rm --volumes foo

    assert_emock_called_with "docker" 14 \
        volume rm foo

    assert_emock_called_with "docker-compose" 0 \
        --verbose                               \
        --file docker-compose.yml               \
        run -T
}

ETEST_docker_compose_run_copy_from_volume()
{
    emock --stdout "tmp/file1" "mktemp"

    emock "docker"
    trap_add "eunmock docker"
    emock "docker-compose"
    trap_add "eunmock docker-compose"

    emock "rm"
    trap_add "eunmock rm"

    etestmsg "Calling docker_compose_run with multiple copy_from_volume"

    # Run this inside a subshell so that we can ensure the traps are getting called to remove the ephemeral volumes
    (
        docker_compose_run                                       \
            --copy-from-volume "foo:/foo:foo"                    \
            --copy-from-volume-delete "foo/bad"                  \
            --copy-from-volume "data:/home/marshall/data:data"   \
            --copy-from-volume "ebash:/home/ebash:/home/baggins" \
            --copy-from-volume-delete "/home/baggins/trash"      \
    )

    assert_emock_called "docker" 3

    assert_emock_called_with "docker" 0 \
        cp "ebash:/home/ebash/." "/home/baggins"

    assert_emock_called_with "docker" 1 \
        cp "data:/home/marshall/data/." "data"

    assert_emock_called_with "docker" 2 \
        cp "foo:/foo/." "foo"

    etestmsg "Verifying post-copy deletes called"
    assert_emock_called "rm" 3

    assert_emock_called_with "rm" 0 \
        --force "tmp/file1"

    assert_emock_called_with "rm" 1 \
        --recursive --force "/home/baggins/trash"

    assert_emock_called_with "rm" 2 \
        --recursive --force "foo/bad"

    assert_emock_called "docker-compose" 3

    assert_emock_called_with "docker-compose" 0 \
        --verbose                               \
        --file docker-compose.yml               \
        run -T

    assert_emock_called_with "docker-compose" 1 \
        --file docker-compose.yml               \
        ps --services

    etestmsg "Validating teardown args"
    assert_emock_called_with "docker-compose" 2 \
        --file docker-compose.yml               \
        down                                    \
        --volumes                               \
        --remove-orphans
}

ETEST_docker_compose_run_passthrough_args()
{
    emock "docker-compose"

    etestmsg "Calling docker_compose_run with passthrough args"

    docker_compose_run --no-wait -- \
        --foo                       \
        --bar

    assert_emock_called "docker-compose" 1

    etestmsg "Verifying args"
    assert_emock_called_with "docker-compose" 0 \
        --verbose                 \
        --file docker-compose.yml \
        run -T                    \
        --foo                     \
        --bar
}

ETEST_docker_compose_run_follow()
{
    emock "docker-compose" '
    {
        if [[ ${called} -eq 0 ]]; then
            echo ""
        else
            echo "42"
        fi
    }'

    emock "docker" '
    {
        if [[ $1 == "logs" ]]; then
            cat expect
        fi
    }'

    etestmsg "Expected output"
	cat <<-END >expect
	{"level":"info","msg":"Starting up server","service":"ServiceA","time":"2022-02-10T00:41:53Z"}
	END
    cat expect

    etestmsg "Calling docker_compose_run with --follow ServiceA"
    docker_compose_run --no-wait --follow ServiceA > actual

    assert_emock_called "docker-compose" 2

    assert_emock_called_with "docker-compose" 0 \
        --verbose                               \
        --file docker-compose.yml               \
        run -T

    assert_emock_called_with "docker-compose" 1 \
        --file docker-compose.yml               \
        ps -q ServiceA

    assert_emock_called "docker" 1

    assert_emock_called_with "docker" 0 \
        logs 42 --follow

    etestmsg "Actual Output"
    cat actual

    etestmsg "Diff"
    diff -u expect actual
}

ETEST_docker_compose_run_follow_all()
{
    emock "docker"
    emock "docker-compose" '
    {
        if [[ ${called} -eq 1 ]]; then
            cat raw
        fi
    }'

    etestmsg "Raw output"
	cat <<-END >raw
	ServiceA                   | {"level":"info","msg":"Starting up server","service":"ServiceA","time":"2022-02-10T00:41:53Z"}
	ServiceB                   | {"level":"info","msg":"Starting up server","service":"ServiceB","time":"2022-02-10T00:41:53Z"}
	ServiceWithAReallyLongName | {"level":"info","msg":"Starting up server","service":"ServiceC","time":"2022-02-10T00:41:53Z"}
	END
    cat raw

    etestmsg "Expected output"
	cat <<-END >expect
	{"level":"info","msg":"Starting up server","service":"ServiceA","time":"2022-02-10T00:41:53Z"}
	{"level":"info","msg":"Starting up server","service":"ServiceB","time":"2022-02-10T00:41:53Z"}
	{"level":"info","msg":"Starting up server","service":"ServiceC","time":"2022-02-10T00:41:53Z"}
	END
    cat expect

    etestmsg "Calling docker_compose_run with --follow-all"
    docker_compose_run --no-wait --follow-all > actual

    assert_emock_called "docker-compose" 2

    assert_emock_called_with "docker-compose" 0 \
        --verbose                               \
        --file docker-compose.yml               \
        run -T

    assert_emock_called_with "docker-compose" 1 \
        --file docker-compose.yml               \
        logs                                    \
        --follow                                \
        --no-color                              \

    assert_emock_called "docker" 0

    etestmsg "Actual Output"
    cat actual

    etestmsg "Diff"
    diff -u expect actual
}

ETEST_docker_compose_run_follow_logfile()
{
    emock "docker-compose" '
    {
        if [[ ${called} -eq 0 ]]; then
            echo ""
        else
            echo "42"
        fi
    }'

    emock "docker" '
    {
        if [[ $1 == "logs" ]]; then
            cat expect
        fi
    }'

    etestmsg "Expected output"
	cat <<-END >expect
	{"level":"info","msg":"Starting up server","service":"ServiceA","time":"2022-02-10T00:41:53Z"}
	END
    cat expect

    etestmsg "Calling docker_compose_run with --follow and --follow-logfile"
    docker_compose_run --no-wait --follow ServiceA --follow-logfile service.log > actual

    assert_emock_called "docker-compose" 2

    assert_emock_called_with "docker-compose" 0 \
        --verbose                               \
        --file docker-compose.yml               \
        run -T

    assert_emock_called_with "docker-compose" 1 \
        --file docker-compose.yml               \
        ps -q ServiceA

    assert_emock_called "docker" 1

    assert_emock_called_with "docker" 0 \
        logs 42 --follow

    etestmsg "Actual Output"
    cat actual

    etestmsg "Diff"
    diff -u expect actual

    etestmsg "Verifying logfile created"
    diff -u expect service.log
}

ETEST_docker_compose_run_follow_json()
{
    emock "docker-compose" '
    {
        if [[ ${called} -eq 0 ]]; then
            echo ""
        else
            echo "42"
        fi
    }'

    emock "docker" '
    {
        if [[ $1 == "logs" ]]; then
            cat raw
        fi
    }'

    etestmsg "Raw output"
	cat <<-END >raw
	{"level":"info","msg":"Starting up server","service":"ServiceA","time":"2022-02-10T00:41:53Z"}
	END
    cat raw

    etestmsg "Expected formatted output"
	cat <<-END >expect
	{
	  "level": "info",
	  "msg": "Starting up server",
	  "service": "ServiceA",
	  "time": "2022-02-10T00:41:53Z"
	}
	END
    cat expect

    etestmsg "Calling docker_compose_run with --follow ServiceA --follow-json"
    docker_compose_run --no-wait --follow ServiceA --follow-json > actual

    assert_emock_called "docker-compose" 2

    assert_emock_called_with "docker-compose" 0 \
        --verbose                               \
        --file docker-compose.yml               \
        run -T

    assert_emock_called_with "docker-compose" 1 \
        --file docker-compose.yml               \
        ps -q ServiceA

    assert_emock_called "docker" 1

    assert_emock_called_with "docker" 0 \
        logs 42 --follow

    etestmsg "Actual Output"
    cat actual

    etestmsg "Diff"
    diff -u expect actual
}

ETEST_docker_compose_run_ssh_port_forward()
{
    export DOCKER_HOST="ssh://someuser@somehost:1234"

    emock "docker-compose"
    emock "docker"
    emock "ssh"

    docker_compose_run --no-wait --ssh-port-forward 8080

    assert_emock_called "docker-compose" 1
    assert_emock_called_with "docker-compose" 0 \
        --verbose                 \
        --file docker-compose.yml \
        run -T

    assert_emock_called "ssh" 1
    assert_emock_called_with "ssh" 0  \
        -NL                           \
        127.0.0.1:8080:127.0.0.1:8080 \
        someuser@somehost:1234
}

ETEST_docker_compose_run_ssh_port_forward_multiple()
{
    export DOCKER_HOST="ssh://someuser@somehost"

    emock "docker-compose"
    emock "docker"
    emock "ssh"

    docker_compose_run --no-wait --ssh-port-forward 8080 --ssh-port-forward 2222

    assert_emock_called "docker-compose" 1
    assert_emock_called_with "docker-compose" 0 \
        --verbose                 \
        --file docker-compose.yml \
        run -T

    assert_emock_called "ssh" 2
    assert_emock_called_with "ssh" 0  \
        -NL                           \
        127.0.0.1:8080:127.0.0.1:8080 \
        someuser@somehost:22

    assert_emock_called_with "ssh" 1  \
        -NL                           \
        127.0.0.1:2222:127.0.0.1:2222 \
        someuser@somehost:22
}

ETEST_docker_compose_run_ssh_port_forward_diff()
{
    export DOCKER_HOST="ssh://someuser@somehost:1234"

    emock "docker-compose"
    emock "docker"
    emock "ssh"

    docker_compose_run --no-wait --ssh-port-forward 80:8080

    assert_emock_called "docker-compose" 1
    assert_emock_called_with "docker-compose" 0 \
        --verbose                 \
        --file docker-compose.yml \
        run -T

    assert_emock_called "ssh" 1
    assert_emock_called_with "ssh" 0 \
        -NL                          \
        127.0.0.1:80:127.0.0.1:8080  \
        someuser@somehost:1234
}

ETEST_docker_compose_run_ssh_port_forward_diff_multiple()
{
    export DOCKER_HOST="ssh://someuser@somehost"

    emock "docker-compose"
    emock "docker"
    emock "ssh"

    docker_compose_run --no-wait --ssh-port-forward 80:8080 --ssh-port-forward 22:2222

    assert_emock_called "docker-compose" 1
    assert_emock_called_with "docker-compose" 0 \
        --verbose                 \
        --file docker-compose.yml \
        run -T

    assert_emock_called "ssh" 2
    assert_emock_called_with "ssh" 0 \
        -NL                          \
        127.0.0.1:80:127.0.0.1:8080  \
        someuser@somehost:22

    assert_emock_called_with "ssh" 1 \
        -NL                          \
        127.0.0.1:22:127.0.0.1:2222  \
        someuser@somehost:22
}
